<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Icon Safe Area Normalizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;1,9..40,400&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #F5F4EF;
  --surface: #FDFCF8;
  --surface-2: #EEECEA;
  --primary: #141414;
  --secondary: #787870;
  --tertiary: #B0B0A6;
  --border: #DDDDD5;
  --border-mid: #C4C4BC;
  --accent: #1B5C48;
  --accent-hover: #134035;
  --radius-sm: 6px;
  --radius-md: 10px;
  --radius-lg: 14px;
  --font: 'DM Sans', -apple-system, 'Helvetica Neue', sans-serif;
  --font-serif: 'DM Serif Display', Georgia, 'Times New Roman', serif;
  --color-circle: #2563EB;
  --color-square: #0D7060;
  --color-vertical: #92400E;
  --color-horizontal: #5B21B6;
  --success: #0D7060;
  --error: #C41E1E;
}

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--primary);
  line-height: 1.5;
  min-height: 100vh;
  font-size: 14px;
}

#svg-sandbox {
  position: absolute; left: -9999px; top: -9999px;
  visibility: hidden; pointer-events: none; width: 200px; height: 200px;
}

#app { max-width: 1080px; margin: 0 auto; padding: 0 40px 80px; }

header {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding: 64px 0 40px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 52px;
  gap: 24px;
}
.header-line {
  display: block;
  height: 1px;
  background: var(--primary);
  width: 0;
  margin-bottom: 24px;
}
header h1 {
  font-family: var(--font-serif);
  font-size: 42px;
  font-weight: 400;
  letter-spacing: -0.9px;
  line-height: 1.05;
  color: var(--primary);
}
.v-badge {
  font-family: var(--font);
  display: inline-block;
  font-size: 10px; font-weight: 500;
  color: var(--tertiary); letter-spacing: 0.2px;
  background: var(--surface-2);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 1px 6px;
  margin-left: 10px;
  vertical-align: middle;
  position: relative; top: -4px;
}
header div p { font-size: 12px; color: var(--secondary); margin-top: 10px; letter-spacing: 0.1px; }

/* Spec toggle */
#spec-toggle-btn {
  padding: 7px 14px;
  background: transparent;
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: var(--font);
  font-size: 12px; color: var(--secondary);
  cursor: pointer; display: flex; align-items: center; gap: 6px;
  transition: all 0.15s; flex-shrink: 0;
}
#spec-toggle-btn:hover { border-color: var(--primary); color: var(--primary); }
#spec-toggle-btn svg { transition: transform 0.2s; }
#spec-toggle-btn.open svg { transform: rotate(180deg); }

#spec-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  margin-bottom: 24px; overflow: hidden; display: none;
}
#spec-panel.open { display: block; }

.spec-inner { padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }

.spec-table-wrap h3 {
  font-size: 10px; font-weight: 600; color: var(--tertiary);
  margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.8px;
}
.spec-table { width: 100%; border-collapse: collapse; font-size: 12px; }
.spec-table th {
  background: var(--surface-2); color: var(--secondary);
  font-weight: 600; padding: 6px 10px; text-align: left;
  font-size: 11px; letter-spacing: 0.2px;
}
.spec-table td { padding: 6px 10px; border-bottom: 1px solid var(--border); }
.spec-table tr:last-child td { border-bottom: none; }

/* Upload zone */
#upload-zone { margin-bottom: 20px; }
#drop-area {
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  background: var(--surface);
  background-image: radial-gradient(circle, var(--border) 1px, transparent 1px);
  background-size: 20px 20px;
  background-position: center center;
  padding: 68px 24px;
  text-align: center; cursor: pointer;
  transition: border-color 0.25s, background-color 0.25s;
}
#drop-area:hover, #drop-area.drag-over {
  border-color: var(--border-mid);
  background-color: rgba(238,236,234,0.9);
}
#drop-area .upload-icon { margin-bottom: 16px; color: var(--tertiary); }
#drop-area .upload-label { font-size: 15px; font-weight: 500; color: var(--primary); margin-bottom: 5px; }
#drop-area .upload-hint { font-size: 12px; color: var(--secondary); }
#browse-link { color: var(--accent); font-weight: 500; cursor: pointer; }

/* Queue bar */
#queue-bar {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-md); padding: 12px 16px;
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 16px; display: none;
}
#queue-bar.visible { display: flex; }
.queue-left { display: flex; align-items: center; gap: 12px; }
#queue-text { font-size: 13px; font-weight: 500; }
#queue-dots { display: flex; gap: 4px; }
.q-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--border); transition: background 0.2s; }
.q-dot.done { background: var(--success); }
.q-dot.active { background: var(--accent); }
#skip-btn {
  font-size: 12px; color: var(--secondary);
  background: none; border: none; cursor: pointer;
  font-family: var(--font); padding: 4px 8px;
  border-radius: var(--radius-sm); transition: background 0.15s;
}
#skip-btn:hover { background: var(--surface-2); }

/* Processing panel */
#process-panel {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-lg); padding: 28px;
  margin-bottom: 20px; display: none;
}
#process-panel.visible { display: block; }
.panel-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 28px; }
.panel-header h2 { font-family: var(--font-serif); font-size: 22px; font-weight: 400; letter-spacing: -0.3px; }
.panel-inner { display: grid; grid-template-columns: 1fr 240px 1fr; gap: 32px; align-items: start; }

.preview-col h3 {
  font-size: 10px; font-weight: 600; color: var(--tertiary);
  text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 10px;
}
.preview-box {
  aspect-ratio: 1; max-width: 220px;
  background: var(--surface-2); border-radius: var(--radius-md);
  border: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center;
  overflow: hidden; position: relative;
}
.preview-box svg { width: 60%; height: 60%; }
.preview-box img { width: 60%; height: 60%; object-fit: contain; }

#norm-preview-wrap {
  aspect-ratio: 1; max-width: 220px;
  background: var(--surface-2); border-radius: var(--radius-md);
  border: 1px solid var(--border); position: relative; overflow: hidden;
}
#norm-icon-layer { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }
#norm-icon-layer svg { width: 100%; height: 100%; }
#norm-overlay-layer { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

/* Size strip */
#size-strip {
  display: flex; align-items: flex-end; gap: 14px;
  margin-top: 12px; padding: 12px;
  background: var(--surface-2); border-radius: var(--radius-sm);
  border: 1px solid var(--border); flex-wrap: wrap;
}
.size-demo { display: flex; flex-direction: column; align-items: center; gap: 5px; }
.size-demo span { font-size: 9px; color: var(--tertiary); letter-spacing: 0.2px; }
.size-demo .icon-frame {
  background: white; border: 1px solid var(--border); border-radius: 2px;
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.size-demo .icon-frame svg { display: block; }

/* Controls column */
.controls-col { display: flex; flex-direction: column; gap: 20px; }
.control-group { display: flex; flex-direction: column; gap: 7px; }
.control-group label {
  font-size: 10px; font-weight: 600; color: var(--tertiary);
  text-transform: uppercase; letter-spacing: 0.8px;
}
#icon-name {
  width: 100%; padding: 9px 12px;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  font-family: var(--font); font-size: 13px; color: var(--primary);
  background: white; outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
}
#icon-name:focus { border-color: var(--border-mid); box-shadow: 0 0 0 3px rgba(0,0,0,0.06); }

/* Keyline buttons */
#keyline-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.keyline-btn {
  display: flex; flex-direction: column; align-items: center; gap: 5px;
  padding: 10px 6px; border: 1px solid var(--border);
  border-radius: var(--radius-md); background: var(--surface-2);
  cursor: pointer; transition: border-color 0.15s, background 0.15s;
  font-family: var(--font); position: relative;
}
.keyline-btn[data-keyline="circle"]  { color: var(--color-circle); }
.keyline-btn[data-keyline="square"]  { color: var(--color-square); }
.keyline-btn[data-keyline="vertical"]    { color: var(--color-vertical); }
.keyline-btn[data-keyline="horizontal"]  { color: var(--color-horizontal); }
.keyline-btn.active[data-keyline="circle"]     { border-color: var(--color-circle);     background: rgba(37,99,235,0.05); }
.keyline-btn.active[data-keyline="square"]     { border-color: var(--color-square);     background: rgba(13,112,96,0.05); }
.keyline-btn.active[data-keyline="vertical"]   { border-color: var(--color-vertical);   background: rgba(146,64,14,0.05); }
.keyline-btn.active[data-keyline="horizontal"] { border-color: var(--color-horizontal); background: rgba(91,33,182,0.05); }
.keyline-btn .kl-shape { width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; }
.keyline-btn .kl-label { font-size: 9px; font-weight: 600; text-align: center; text-transform: uppercase; letter-spacing: 0.3px; }
.auto-badge {
  position: absolute; top: 4px; right: 4px;
  font-size: 7px; font-weight: 700; letter-spacing: 0.3px;
  background: var(--primary); color: white;
  padding: 1px 4px; border-radius: 3px; opacity: 0; transition: opacity 0.15s;
}
.keyline-btn.auto-detected .auto-badge { opacity: 1; }

/* Size buttons */
#size-buttons { display: flex; gap: 5px; }
.size-btn {
  flex: 1; padding: 8px 4px;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  background: var(--surface-2); font-family: var(--font);
  font-size: 12px; font-weight: 500; color: var(--secondary);
  cursor: pointer; transition: all 0.15s; text-align: center;
}
.size-btn:hover { border-color: var(--border-mid); color: var(--primary); }
.size-btn.active { border-color: var(--primary); background: var(--primary); color: white; }

/* Save button */
#save-btn {
  width: 100%; padding: 11px;
  background: var(--primary); color: white; border: none;
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 14px; font-weight: 500; cursor: pointer;
  transition: opacity 0.15s; letter-spacing: -0.1px;
}
#save-btn:hover { opacity: 0.8; }
#save-btn:disabled { opacity: 0.3; cursor: not-allowed; }

/* Error */
.proc-error {
  background: rgba(196,30,30,0.05); border: 1px solid rgba(196,30,30,0.15);
  border-radius: var(--radius-sm); padding: 10px 12px;
  font-size: 12px; color: var(--error); display: none;
}
.proc-error.visible { display: block; }

/* Library */
#library-section {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-lg); padding: 28px;
}
#library-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
#library-header h2 { font-family: var(--font-serif); font-size: 24px; font-weight: 400; letter-spacing: -0.4px; }
#library-count { font-size: 13px; font-weight: 400; color: var(--secondary); }

#export-zip-btn {
  padding: 7px 14px; background: transparent;
  color: var(--secondary); border: 1px solid var(--border);
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s;
}
#export-zip-btn:hover { border-color: var(--primary); color: var(--primary); }
#export-zip-btn:disabled { opacity: 0.35; cursor: not-allowed; }

#filter-bar { display: flex; gap: 6px; margin-bottom: 24px; flex-wrap: wrap; }
.filter-btn {
  padding: 4px 12px; border-radius: 4px;
  border: 1px solid var(--border); background: transparent;
  font-family: var(--font); font-size: 11px; font-weight: 500;
  color: var(--secondary); cursor: pointer; transition: all 0.15s;
}
.filter-btn:hover { border-color: var(--border-mid); color: var(--primary); }
.filter-btn.active { background: var(--primary); border-color: var(--primary); color: white; }

#library-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }

/* Icon card */
.icon-card {
  background: var(--surface-2); border: 1px solid var(--border);
  border-radius: var(--radius-md); padding: 14px 10px 10px;
  display: flex; flex-direction: column; align-items: center; gap: 8px;
  position: relative; transition: border-color 0.15s; cursor: default;
}
.icon-card:hover { border-color: var(--border-mid); }
.icon-card:hover .card-actions { opacity: 1; }
.icon-thumb {
  width: 56px; height: 56px; background: white;
  border-radius: 6px; border: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center;
}
.icon-thumb svg { width: 36px; height: 36px; }
.icon-card-name {
  font-size: 11px; font-weight: 500; color: var(--primary);
  text-align: center; word-break: break-all; max-width: 100%; line-height: 1.3;
}
.keyline-badge {
  font-size: 9px; font-weight: 600; padding: 2px 7px;
  border-radius: 3px; text-transform: uppercase; letter-spacing: 0.4px;
}
.keyline-badge.circle     { background: rgba(37,99,235,0.08);  color: var(--color-circle); }
.keyline-badge.square     { background: rgba(13,112,96,0.08);  color: var(--color-square); }
.keyline-badge.vertical   { background: rgba(146,64,14,0.08);  color: var(--color-vertical); }
.keyline-badge.horizontal { background: rgba(91,33,182,0.08);  color: var(--color-horizontal); }
.size-label { font-size: 9px; color: var(--tertiary); margin-top: -4px; }

.card-actions { position: absolute; top: 6px; right: 6px; display: flex; gap: 3px; opacity: 0; transition: opacity 0.15s; }
.card-action-btn {
  width: 24px; height: 24px; border-radius: 4px;
  border: 1px solid var(--border); background: white;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; font-size: 11px; transition: all 0.15s; color: var(--secondary);
}
.card-action-btn:hover { border-color: var(--border-mid); }
.card-action-btn.delete:hover { background: rgba(196,30,30,0.06); border-color: rgba(196,30,30,0.3); color: var(--error); }

/* Empty state */
#empty-state { text-align: center; padding: 52px 24px; color: var(--secondary); display: none; }
#empty-state.visible { display: block; }
#empty-state svg { opacity: 1; }
#empty-state p { font-size: 13px; }

/* Toast */
#toast {
  position: fixed; bottom: 28px; left: 50%;
  transform: translateX(-50%) translateY(80px);
  background: var(--primary); color: white;
  padding: 9px 18px; border-radius: 6px;
  font-size: 12px; font-weight: 500;
  box-shadow: 0 4px 24px rgba(0,0,0,0.18);
  transition: transform 0.3s cubic-bezier(0.34,1.56,0.64,1);
  z-index: 100; pointer-events: none; white-space: nowrap;
}
#toast.show { transform: translateX(-50%) translateY(0); }
#toast.success { background: var(--success); }
#toast.error { background: var(--error); }

@media (max-width: 800px) {
  #app { padding: 0 20px 60px; }
  .panel-inner { grid-template-columns: 1fr; }
  .spec-inner { grid-template-columns: 1fr; }
  header h1 { font-size: 28px; }
}

/* ── Grain texture overlay ──────────────────────────────── */
body::after {
  content: '';
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9998;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.3 0 0 0 0 0.28 0 0 0 0 0.22 0 0 0 0.09 0'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)'/%3E%3C/svg%3E");
}

/* ── Keyframes ──────────────────────────────────────────── */
@keyframes fadeUp {
  from { opacity: 0; transform: translateY(16px); }
  to   { opacity: 1; transform: translateY(0); }
}
@keyframes scaleIn {
  from { opacity: 0; transform: scale(0.97) translateY(6px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}
@keyframes lineDraw {
  from { width: 0; opacity: 0; }
  to   { width: 100%; opacity: 1; }
}
@keyframes uploadBob {
  0%, 100% { transform: translateY(0); }
  50%       { transform: translateY(-6px); }
}
@keyframes cardIn {
  from { opacity: 0; transform: translateY(10px) scale(0.96); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes pulseBorder {
  0%, 100% { border-color: var(--border); }
  50%       { border-color: var(--border-mid); }
}

/* ── Page load entrance ─────────────────────────────────── */
header         { animation: fadeUp 0.55s ease-out both; }
#upload-zone   { animation: fadeUp 0.55s 0.10s ease-out both; }
#library-section { animation: fadeUp 0.55s 0.18s ease-out both; }

/* ── Header animated line ───────────────────────────────── */
.header-line {
  animation: lineDraw 0.9s 0.15s cubic-bezier(0.25, 1, 0.5, 1) both;
}

/* ── Upload icon bobbing ────────────────────────────────── */
#drop-area .upload-icon {
  animation: uploadBob 3s 1.2s ease-in-out infinite;
}
#drop-area.drag-over .upload-icon,
#drop-area:hover .upload-icon {
  animation: none;
  transform: scale(1.08);
  transition: transform 0.2s ease-out;
}

/* ── Upload icon color on hover ─────────────────────────── */
#drop-area { transition: border-color 0.25s, background-color 0.25s; }
#drop-area:hover .upload-icon, #drop-area.drag-over .upload-icon { color: var(--accent); }
#drop-area .upload-icon { transition: color 0.2s; color: var(--tertiary); }

/* ── Card animations & hover ────────────────────────────── */
.icon-card {
  transition: border-color 0.18s, transform 0.2s cubic-bezier(0.34,1.56,0.64,1), box-shadow 0.2s ease-out;
}
.icon-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 18px rgba(0,0,0,0.07);
}
.icon-card.card-anim { animation: cardIn 0.3s ease-out both; }

/* ── Process panel entrance ─────────────────────────────── */
#process-panel.visible { animation: scaleIn 0.28s ease-out both; }

/* ── Keyline btn hover lift ─────────────────────────────── */
.keyline-btn {
  transition: border-color 0.15s, background 0.15s, transform 0.18s cubic-bezier(0.34,1.56,0.64,1);
}
.keyline-btn:hover:not(.active) { transform: translateY(-2px); }

/* ── Save button — subtle shimmer on hover ──────────────── */
#save-btn {
  position: relative;
  overflow: hidden;
}
#save-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.12) 50%, transparent 100%);
  transform: translateX(-100%);
  transition: transform 0s;
}
#save-btn:hover:not(:disabled)::after {
  transform: translateX(100%);
  transition: transform 0.45s ease-in-out;
}

/* ── Browse link pulse ──────────────────────────────────── */
#browse-link {
  position: relative;
}
#browse-link::after {
  content: '';
  position: absolute;
  bottom: -1px; left: 0; right: 0;
  height: 1px;
  background: var(--accent);
  transform: scaleX(0);
  transform-origin: left;
  transition: transform 0.2s ease-out;
}
#browse-link:hover::after { transform: scaleX(1); }

/* ── Empty state ─────────────────────────────────────────── */
#empty-state {
  padding: 72px 24px;
}
.empty-glyph {
  width: 72px; height: 72px;
  margin: 0 auto 20px;
  opacity: 0.15;
}
#empty-state p { font-size: 13px; color: var(--secondary); }
#empty-state .empty-hint {
  font-size: 11px; color: var(--tertiary);
  margin-top: 5px; letter-spacing: 0.2px;
}

/* ── Spec table refinement ──────────────────────────────── */
.spec-table-wrap h3 {
  font-family: var(--font);
  font-size: 9px; letter-spacing: 1.1px;
  text-transform: uppercase; font-weight: 600;
}

/* ── Upload label refinement ────────────────────────────── */
#drop-area .upload-label { font-size: 14px; font-weight: 400; color: var(--secondary); }
#drop-area .upload-hint  { font-size: 11px; color: var(--tertiary); margin-top: 3px; }

/* ── Queue bar dot animation ────────────────────────────── */
.q-dot.active { animation: pulseBorder 1s infinite; background: var(--accent); }

/* Overlay toggle */
.norm-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
.norm-header h3 { margin-bottom: 0; }
#overlay-toggle {
  width: 24px; height: 24px; border-radius: 4px;
  border: 1px solid var(--border); background: white;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  color: var(--tertiary); transition: all 0.15s; flex-shrink: 0;
}
#overlay-toggle.active { border-color: var(--border-mid); color: var(--secondary); }
#overlay-toggle:hover { border-color: var(--border-mid); color: var(--primary); }

/* Card checkbox */
.card-checkbox {
  position: absolute; top: 6px; left: 6px;
  width: 20px; height: 20px; border-radius: 4px;
  border: 1px solid var(--border); background: white;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  opacity: 0; transition: opacity 0.15s, border-color 0.15s, background 0.15s;
  color: white; z-index: 2;
}
.icon-card:hover .card-checkbox,
.icon-card.selected .card-checkbox { opacity: 1; }
.card-checkbox.checked { background: var(--primary); border-color: var(--primary); opacity: 1; }
.icon-card.selected { border-color: var(--border-mid); box-shadow: 0 0 0 2px rgba(0,0,0,0.07); }

/* Selection bar */
#selection-bar { display: none; align-items: center; gap: 10px; padding: 14px 0 0; border-top: 1px solid var(--border); margin-top: 16px; }
#selection-bar.visible { display: flex; }
#sel-count { font-size: 12px; font-weight: 500; color: var(--primary); flex: 1; }
#sel-download-btn {
  padding: 7px 14px; background: var(--primary); color: white; border: none;
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 12px; font-weight: 500; cursor: pointer; transition: opacity 0.15s;
}
#sel-download-btn:hover { opacity: 0.8; }
#sel-clear-btn {
  padding: 7px 12px; background: transparent; color: var(--secondary);
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  font-family: var(--font); font-size: 12px; cursor: pointer; transition: all 0.15s;
}
#sel-clear-btn:hover { border-color: var(--border-mid); color: var(--primary); }
</style>
</head>
<body>

<!-- Hidden sandbox for getBBox() — must be in visible DOM -->
<div id="svg-sandbox" aria-hidden="true"></div>

<div id="app">
  <header>
    <div>
      <span class="header-line"></span>
      <h1>Icon Safe Area Normalizer <span class="v-badge">v3.0</span></h1>
      <p>Upload SVGs · normalize strokes to 1dp · fit to keyline · save to library</p>
    </div>
    <button id="spec-toggle-btn">
      <span>Spec reference</span>
      <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
  </header>

  <!-- Collapsible spec panel -->
  <div id="spec-panel">
    <div class="spec-inner">
      <div class="spec-table-wrap">
        <h3>Canvas &amp; Safe Area</h3>
        <table class="spec-table">
          <thead>
            <tr><th>Size</th><th>Canvas</th><th>Safe Zone</th><th>Padding</th><th>Stroke</th></tr>
          </thead>
          <tbody>
            <tr><td>16dp</td><td>16×16</td><td>14×14</td><td>1dp</td><td>1dp</td></tr>
            <tr><td>24dp</td><td>24×24</td><td>20×20</td><td>2dp</td><td>1dp</td></tr>
            <tr><td>32dp</td><td>32×32</td><td>28×28</td><td>2dp</td><td>1dp</td></tr>
          </tbody>
        </table>
      </div>
      <div class="spec-table-wrap">
        <h3>Keyline Shapes (W × H)</h3>
        <table class="spec-table">
          <thead>
            <tr><th>Size</th><th>Circle</th><th>Square</th><th>Vertical</th><th>Horizontal</th></tr>
          </thead>
          <tbody>
            <tr><td>16dp</td><td>14dp ⌀</td><td>12×12</td><td>10×14</td><td>14×10</td></tr>
            <tr><td>24dp</td><td>20dp ⌀</td><td>18×18</td><td>16×20</td><td>20×16</td></tr>
            <tr><td>32dp</td><td>28dp ⌀</td><td>26×26</td><td>24×28</td><td>28×24</td></tr>
          </tbody>
        </table>
        <p style="font-size:11px;color:var(--secondary);margin-top:8px">Circle: circular icons · Square: geometric/square · Vertical: portrait (person, phone, door) · Horizontal: landscape (card, monitor)</p>
      </div>
    </div>
  </div>

  <!-- Upload zone -->
  <div id="upload-zone">
    <input type="file" id="file-input" accept=".svg" multiple style="display:none">
    <div id="drop-area">
      <div class="upload-icon">
        <svg width="40" height="40" viewBox="0 0 40 40" fill="none">
          <rect x="6" y="12" width="28" height="22" rx="3" stroke="currentColor" stroke-width="1.5"/>
          <path d="M14 20l6-6 6 6M20 14v14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <p class="upload-label">Drop SVG files here or <span id="browse-link">browse</span></p>
      <p class="upload-hint">Supports multiple files at once</p>
    </div>
  </div>

  <!-- Queue indicator -->
  <div id="queue-bar">
    <div class="queue-left">
      <span id="queue-text">Processing 1 of 1</span>
      <div id="queue-dots"></div>
    </div>
    <button id="skip-btn">Skip this icon</button>
  </div>

  <!-- Processing panel -->
  <div id="process-panel">
    <div class="panel-header">
      <h2 id="panel-filename">Icon name</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <div id="proc-error" class="proc-error">Could not parse SVG</div>
      </div>
    </div>

    <div class="panel-inner">
      <!-- Original preview -->
      <div class="preview-col">
        <h3>Original</h3>
        <div class="preview-box" id="original-preview"></div>
        <p id="original-info" style="font-size:11px;color:var(--secondary);margin-top:8px;text-align:center"></p>
      </div>

      <!-- Controls -->
      <div class="controls-col">
        <div class="control-group">
          <label>Icon name</label>
          <input type="text" id="icon-name" placeholder="e.g. arrow-right">
        </div>

        <div class="control-group">
          <label>Keyline shape</label>
          <div id="keyline-buttons">
            <button class="keyline-btn" data-keyline="circle">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <circle cx="17" cy="17" r="12" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Circle</span>
            </button>
            <button class="keyline-btn" data-keyline="square">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="5" y="5" width="24" height="24" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Square</span>
            </button>
            <button class="keyline-btn" data-keyline="vertical">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="8" y="3" width="18" height="28" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Vertical</span>
            </button>
            <button class="keyline-btn" data-keyline="horizontal">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="3" y="8" width="28" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Horizontal</span>
            </button>
          </div>
        </div>

        <div class="control-group">
          <label>Canvas size</label>
          <div id="size-buttons">
            <button class="size-btn" data-size="16">16dp</button>
            <button class="size-btn active" data-size="24">24dp</button>
            <button class="size-btn" data-size="32">32dp</button>
          </div>
        </div>

        <button id="save-btn">Save to Library</button>
      </div>

      <!-- Normalized preview -->
      <div class="preview-col">
        <div class="norm-header">
          <h3>Normalized <span id="norm-info" style="font-weight:400;text-transform:none;letter-spacing:0"></span></h3>
          <button id="overlay-toggle" class="active" title="Toggle keyline overlay">
            <svg width="13" height="10" viewBox="0 0 13 10" fill="none">
              <ellipse cx="6.5" cy="5" rx="5.5" ry="4" stroke="currentColor" stroke-width="1.2"/>
              <circle cx="6.5" cy="5" r="1.8" fill="currentColor"/>
            </svg>
          </button>
        </div>
        <div id="norm-preview-wrap">
          <div id="norm-icon-layer"></div>
          <svg id="norm-overlay-layer" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div id="size-strip"></div>
      </div>
    </div>
  </div>

  <!-- Library -->
  <div id="library-section">
    <div id="library-header">
      <h2>Icon Library <span id="library-count">(0 icons)</span></h2>
      <button id="export-zip-btn" disabled>Export all as ZIP</button>
    </div>
    <div id="filter-bar">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="circle">Circle</button>
      <button class="filter-btn" data-filter="square">Square</button>
      <button class="filter-btn" data-filter="vertical">Vertical</button>
      <button class="filter-btn" data-filter="horizontal">Horizontal</button>
    </div>
    <div id="library-grid"></div>
    <div id="selection-bar">
      <span id="sel-count">0 selected</span>
      <button id="sel-download-btn">↓ Download (all 3 sizes)</button>
      <button id="sel-clear-btn">Clear</button>
    </div>
    <div id="empty-state" class="visible">
      <div class="empty-glyph">
        <svg viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="36" cy="36" r="28" stroke="currentColor" stroke-width="1" stroke-dasharray="3 3"/>
          <rect x="20" y="20" width="32" height="32" rx="2" stroke="currentColor" stroke-width="1.5"/>
          <line x1="36" y1="8" x2="36" y2="64" stroke="currentColor" stroke-width="1"/>
          <line x1="8" y1="36" x2="64" y2="36" stroke="currentColor" stroke-width="1"/>
          <circle cx="36" cy="36" r="3" fill="currentColor" opacity="0.4"/>
        </svg>
      </div>
      <p>No icons yet</p>
      <p class="empty-hint">Drop SVG files above to get started</p>
    </div>
  </div>
</div>

<div id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════════
// SPEC DATA
// ═══════════════════════════════════════════════════════════
const SPEC = {
  // keylines[size][type] = { w: width, h: height } in dp
  // For circle: w = h = diameter
  keylines: {
    16: {
      circle:     { w: 14, h: 14 },
      square:     { w: 12, h: 12 },
      vertical:   { w: 10, h: 14 },  // 10dp wide × 14dp tall (portrait)
      horizontal: { w: 14, h: 10 },  // 14dp wide × 10dp tall (landscape)
    },
    24: {
      circle:     { w: 20, h: 20 },
      square:     { w: 18, h: 18 },
      vertical:   { w: 16, h: 20 },  // 16dp wide × 20dp tall
      horizontal: { w: 20, h: 16 },  // 20dp wide × 16dp tall
    },
    32: {
      circle:     { w: 28, h: 28 },
      square:     { w: 26, h: 26 },
      vertical:   { w: 24, h: 28 },  // 24dp wide × 28dp tall
      horizontal: { w: 28, h: 24 },  // 28dp wide × 24dp tall
    },
  },
  padding: { 16: 1, 24: 2, 32: 2 },
  keylineColors: {
    circle: '#007aff',
    square: '#187A6C',
    vertical: '#B8912A',
    horizontal: '#7B5EA7',
  },
};

// ═══════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════
const state = {
  queue: [],        // Array of File objects
  queueIndex: 0,
  currentRawSvg: null,
  currentKeyline: 'square',
  currentSize: 24,
  currentNormalizedSvg: null,
  library: [],
  filter: 'all',
  overlayVisible: true,
  selectedIds: new Set(),
};

// ═══════════════════════════════════════════════════════════
// STORAGE
// ═══════════════════════════════════════════════════════════
const STORAGE_KEY = 'iconNormalizerLibrary_v1';

function loadLibrary() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    state.library = raw ? JSON.parse(raw) : [];
  } catch (e) {
    state.library = [];
  }
}

function saveLibraryToStorage() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.library));
  } catch (e) {
    if (e.name === 'QuotaExceededError') {
      showToast('Storage full — some older icons may need to be removed', 'error');
    }
  }
}

function addToLibrary(icon) {
  state.library.unshift(icon);
  saveLibraryToStorage();
}

function deleteFromLibrary(id) {
  state.library = state.library.filter(ic => ic.id !== id);
  saveLibraryToStorage();
  renderLibrary();
  showToast('Icon removed');
}

// ═══════════════════════════════════════════════════════════
// TRANSFORM MATH + PATH FLATTENING
// ═══════════════════════════════════════════════════════════

// Affine matrix: [a, b, c, d, e, f]  →  x' = a·x + c·y + e,  y' = b·x + d·y + f
function matMul(p, q) {
  return [
    p[0]*q[0]+p[2]*q[1], p[1]*q[0]+p[3]*q[1],
    p[0]*q[2]+p[2]*q[3], p[1]*q[2]+p[3]*q[3],
    p[0]*q[4]+p[2]*q[5]+p[4], p[1]*q[4]+p[3]*q[5]+p[5],
  ];
}
function matApply(m, x, y) { return [m[0]*x+m[2]*y+m[4], m[1]*x+m[3]*y+m[5]]; }
function matScale(m) { return Math.sqrt(m[0]*m[0]+m[1]*m[1]); } // uniform scale magnitude

function parseTransformStr(s) {
  if (!s) return [1,0,0,1,0,0];
  let m = [1,0,0,1,0,0];
  const re = /(\w+)\s*\(([^)]*)\)/g;
  let match;
  while ((match = re.exec(s)) !== null) {
    const fn = match[1];
    const a = match[2].trim().split(/[\s,]+/).map(Number);
    let t = [1,0,0,1,0,0];
    if      (fn==='translate') t = [1,0,0,1,a[0]||0,a[1]||0];
    else if (fn==='scale')     { const sx=a[0]||1,sy=a.length>1?a[1]:sx; t=[sx,0,0,sy,0,0]; }
    else if (fn==='matrix')    t = a.slice(0,6);
    else if (fn==='rotate') {
      const ang=(a[0]||0)*Math.PI/180, cos=Math.cos(ang), sin=Math.sin(ang);
      const cx=a[1]||0, cy=a[2]||0;
      t = [cos, sin, -sin, cos, cx-cos*cx+sin*cy, cy-sin*cx-cos*cy];
    }
    m = matMul(m, t);
  }
  return m;
}

// Transform SVG path d attribute by matrix m
function transformPathD(d, m) {
  if (!d) return d;
  const tokens = [];
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match;
  while ((match = re.exec(d)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const out = [];
  let i = 0, cx = 0, cy = 0, sx = 0, sy = 0, prevCmd = 'M';
  const n = () => tokens[i++];
  const f = v => parseFloat(v.toFixed(4));

  while (i < tokens.length) {
    let cmd = typeof tokens[i] === 'string' ? (prevCmd = tokens[i++]) : prevCmd;
    const C = cmd.toUpperCase(), rel = cmd !== C;

    if (C === 'Z') { out.push('Z'); cx=sx; cy=sy; continue; }

    if (C === 'M') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`M${f(nx)},${f(ny)}`);
      cx=x;cy=y;sx=x;sy=y; prevCmd=rel?'l':'L';
    } else if (C === 'L') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`L${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'H') {
      let x=n(); if (rel) x+=cx;
      const [nx,ny]=matApply(m,x,cy); out.push(`L${f(nx)},${f(ny)}`); cx=x;
    } else if (C === 'V') {
      let y=n(); if (rel) y+=cy;
      const [nx,ny]=matApply(m,cx,y); out.push(`L${f(nx)},${f(ny)}`); cy=y;
    } else if (C === 'C') {
      let x1=n(),y1=n(),x2=n(),y2=n(),x=n(),y=n();
      if (rel){x1+=cx;y1+=cy;x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`C${f(a1)},${f(b1)},${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'S') {
      let x2=n(),y2=n(),x=n(),y=n(); if (rel){x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`S${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'Q') {
      let x1=n(),y1=n(),x=n(),y=n(); if (rel){x1+=cx;y1+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[nx,ny]=matApply(m,x,y);
      out.push(`Q${f(a1)},${f(b1)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'T') {
      let x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`T${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'A') {
      let rx=n(),ry=n(),rot=n(),la=n(),sw=n(),x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const sc=matScale(m), [nx,ny]=matApply(m,x,y);
      out.push(`A${f(rx*sc)},${f(ry*sc)},${rot},${la},${sw},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else { while (i<tokens.length && typeof tokens[i]==='number') i++; }
  }
  return out.join(' ');
}

// Apply matrix m to element's own coordinates (shape elements only)
const FLATTEN_TAGS = new Set(['path','line','circle','ellipse','rect','polyline','polygon']);
function flattenElement(el, m) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v.toFixed(4));
  const sc = matScale(m);
  if (tag === 'path') {
    const d = el.getAttribute('d'); if (d) el.setAttribute('d', transformPathD(d, m));
  } else if (tag === 'line') {
    const [nx1,ny1]=matApply(m,+(el.getAttribute('x1')||0),+(el.getAttribute('y1')||0));
    const [nx2,ny2]=matApply(m,+(el.getAttribute('x2')||0),+(el.getAttribute('y2')||0));
    el.setAttribute('x1',f(nx1));el.setAttribute('y1',f(ny1));
    el.setAttribute('x2',f(nx2));el.setAttribute('y2',f(ny2));
  } else if (tag === 'circle') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('r',f(+(el.getAttribute('r')||0)*sc));
  } else if (tag === 'ellipse') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('rx',f(+(el.getAttribute('rx')||0)*sc));
    el.setAttribute('ry',f(+(el.getAttribute('ry')||0)*sc));
  } else if (tag === 'rect') {
    const [nx,ny]=matApply(m,+(el.getAttribute('x')||0),+(el.getAttribute('y')||0));
    el.setAttribute('x',f(nx));el.setAttribute('y',f(ny));
    el.setAttribute('width',f(+(el.getAttribute('width')||0)*sc));
    el.setAttribute('height',f(+(el.getAttribute('height')||0)*sc));
    const rx=el.getAttribute('rx'),ry=el.getAttribute('ry');
    if (rx) el.setAttribute('rx',f(+rx*sc));
    if (ry) el.setAttribute('ry',f(+ry*sc));
  } else if (tag === 'polyline' || tag === 'polygon') {
    const pts=(el.getAttribute('points')||'').trim().split(/[\s,]+/).map(Number);
    const out=[];
    for (let k=0;k<pts.length-1;k+=2){const[nx,ny]=matApply(m,pts[k],pts[k+1]);out.push(`${f(nx)},${f(ny)}`);}
    el.setAttribute('points',out.join(' '));
  }
  el.removeAttribute('transform');
}

// Recursively walk SVG tree, accumulate group transforms, flatten each shape into parentMat space
function walkFlatten(node, parentMat) {
  if (node.nodeType !== 1) return;
  const tag = node.tagName.toLowerCase();
  if (FLATTEN_TAGS.has(tag)) {
    const elMat = parseTransformStr(node.getAttribute('transform'));
    flattenElement(node, matMul(parentMat, elMat));
  } else {
    const groupMat = (tag === 'g' || tag === 'svg')
      ? matMul(parentMat, parseTransformStr(node.getAttribute('transform')))
      : parentMat;
    if (tag === 'g') node.removeAttribute('transform');
    Array.from(node.childNodes).forEach(child => walkFlatten(child, groupMat));
  }
}

// ═══════════════════════════════════════════════════════════
// SVG PARSING + NORMALIZATION
// ═══════════════════════════════════════════════════════════

function parseSVGString(svgString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgString, 'image/svg+xml');
  const root = doc.documentElement;
  if (root.querySelector('parsererror')) {
    throw new Error('Invalid SVG — parse error');
  }
  if (root.tagName.toLowerCase() !== 'svg') {
    throw new Error('File does not contain an SVG root element');
  }
  return { doc, root };
}

function ensureViewBox(svgEl) {
  // Make sure we have a viewBox
  const vb = svgEl.viewBox && svgEl.viewBox.baseVal;
  if (vb && vb.width > 0 && vb.height > 0) {
    return { x: vb.x, y: vb.y, w: vb.width, h: vb.height };
  }
  // Fall back to width/height attrs
  const w = parseFloat(svgEl.getAttribute('width')) || 24;
  const h = parseFloat(svgEl.getAttribute('height')) || 24;
  svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
  return { x: 0, y: 0, w, h };
}

function getContentBBox(svgString) {
  // Render in sandbox, get the bounding box of all visible content
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  if (!liveSvg) return null;

  // Force a display size so layout is computed
  liveSvg.removeAttribute('width');
  liveSvg.removeAttribute('height');
  liveSvg.style.width = '200px';
  liveSvg.style.height = '200px';

  // Ensure viewBox exists
  const vbInfo = ensureViewBox(liveSvg);

  // Create a temporary g containing all drawable children
  const tempG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  const drawable = Array.from(liveSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  drawable.forEach(child => tempG.appendChild(child.cloneNode(true)));
  liveSvg.appendChild(tempG);

  let bbox = null;
  try {
    bbox = tempG.getBBox();
  } catch (e) { /* getBBox not available */ }

  liveSvg.removeChild(tempG);
  sandbox.innerHTML = '';

  if (!bbox || bbox.width === 0 || bbox.height === 0) {
    // Fallback: use viewBox dimensions
    return { x: vbInfo.x, y: vbInfo.y, width: vbInfo.w, height: vbInfo.h, vbInfo };
  }

  return { x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height, vbInfo };
}

function detectKeyline(svgString, bbox) {
  // Quick check for circle/ellipse as dominant element
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  let hasCircleShape = false;
  if (liveSvg) {
    const circles = liveSvg.querySelectorAll('circle, ellipse');
    const otherShapes = liveSvg.querySelectorAll('path, rect, line, polyline, polygon');
    // If there are circles and no (or few) other shapes → circle keyline
    if (circles.length > 0 && otherShapes.length === 0) hasCircleShape = true;
    if (circles.length > 0 && otherShapes.length <= 1) hasCircleShape = true;
  }
  sandbox.innerHTML = '';

  if (!bbox || bbox.width === 0 || bbox.height === 0) return 'square';

  const ratio = bbox.width / bbox.height;
  const isSquarish = Math.abs(ratio - 1) < 0.15;

  if (isSquarish && hasCircleShape) return 'circle';
  if (isSquarish) return 'square';
  if (ratio < 0.85) return 'vertical';   // taller than wide
  if (ratio > 1.15) return 'horizontal'; // wider than tall
  return 'square';
}

// Convert any SVG shape element to a path `d` string.
// Assumes coordinates are already in their final (dp) space.
function shapeToPathD(el) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v || 0);

  if (tag === 'path') return el.getAttribute('d') || '';

  if (tag === 'line') {
    const x1 = f(el.getAttribute('x1')), y1 = f(el.getAttribute('y1'));
    const x2 = f(el.getAttribute('x2')), y2 = f(el.getAttribute('y2'));
    return `M ${x1} ${y1} L ${x2} ${y2}`;
  }

  if (tag === 'rect') {
    const x = f(el.getAttribute('x')), y = f(el.getAttribute('y'));
    const w = f(el.getAttribute('width')), h = f(el.getAttribute('height'));
    const rx = Math.min(f(el.getAttribute('rx')), w / 2);
    const ry = Math.min(f(el.getAttribute('ry') || el.getAttribute('rx')), h / 2);
    if (rx === 0 && ry === 0) return `M ${x} ${y} H ${x + w} V ${y + h} H ${x} Z`;
    return `M ${x + rx} ${y} H ${x + w - rx} A ${rx} ${ry} 0 0 1 ${x + w} ${y + ry} V ${y + h - ry} A ${rx} ${ry} 0 0 1 ${x + w - rx} ${y + h} H ${x + rx} A ${rx} ${ry} 0 0 1 ${x} ${y + h - ry} V ${y + ry} A ${rx} ${ry} 0 0 1 ${x + rx} ${y} Z`;
  }

  if (tag === 'circle') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const r = f(el.getAttribute('r'));
    return `M ${cx - r} ${cy} A ${r} ${r} 0 1 0 ${cx + r} ${cy} A ${r} ${r} 0 1 0 ${cx - r} ${cy} Z`;
  }

  if (tag === 'ellipse') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const rx2 = f(el.getAttribute('rx')), ry2 = f(el.getAttribute('ry'));
    return `M ${cx - rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx + rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx - rx2} ${cy} Z`;
  }

  if (tag === 'polyline' || tag === 'polygon') {
    const pts = (el.getAttribute('points') || '').trim().split(/[\s,]+/);
    const pairs = [];
    for (let i = 0; i + 1 < pts.length; i += 2) pairs.push(`${pts[i]} ${pts[i + 1]}`);
    if (!pairs.length) return '';
    const d = `M ${pairs.join(' L ')}`;
    return tag === 'polygon' ? d + ' Z' : d;
  }
  return '';
}

// Returns true if the path `d` string represents a closed shape (ends with Z/z).
function isClosedPath(d) {
  return /[Zz]\s*$/.test((d || '').trim());
}

// Compute the inner boundary of a closed path by scaling all coordinates toward the
// path's bounding-box center, insetting by 1dp on each side. Uses transformPathD.
function makeInnerDFromPath(outerD) {
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match, cx = 0, cy = 0, cmd = 'M';
  const tokens = [];
  while ((match = re.exec(outerD)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const coords = [];
  let i = 0;
  while (i < tokens.length) {
    if (typeof tokens[i] === 'string') { cmd = tokens[i++]; continue; }
    const C = cmd.toUpperCase(), rel = cmd !== C;
    if (C === 'Z') continue;
    if (C === 'M' || C === 'L' || C === 'T') {
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'H') {
      let x = tokens[i++]; if (rel) x += cx; cx = x;
      coords.push([cx, cy]);
    } else if (C === 'V') {
      let y = tokens[i++]; if (rel) y += cy; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'C') {
      for (let j = 0; j < 3; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 2) { cx = x; cy = y; }
      }
    } else if (C === 'S' || C === 'Q') {
      for (let j = 0; j < 2; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 1) { cx = x; cy = y; }
      }
    } else if (C === 'A') {
      i += 5; // skip rx, ry, rot, la, sw
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else { i++; }
  }

  if (coords.length < 2) return '';
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  coords.forEach(([x, y]) => {
    if (x < minX) minX = x; if (x > maxX) maxX = x;
    if (y < minY) minY = y; if (y > maxY) maxY = y;
  });
  const w = maxX - minX, h = maxY - minY;
  if (w <= 2 || h <= 2) return ''; // inner shape would collapse

  const cxB = minX + w / 2, cyB = minY + h / 2;
  const sxF = (w - 2) / w, syF = (h - 2) / h; // inset by 1dp on each side
  // Scale toward bbox center: x' = cx + (x - cx) * sx = sx*x + cx*(1-sx)
  const mat = [sxF, 0, 0, syF, cxB * (1 - sxF), cyB * (1 - syF)];
  return transformPathD(outerD, mat);
}

// Merge all shapes in contentG into flat compound paths grouped by style signature.
// Removes all <g> wrappers → Figma sees: icon-content > 1–N <path> elements (flat Vectors).
//
// Key behaviour for inside-stroke shapes (the common Figma export pattern):
//   Figma exports "Inside" stroke by doubling stroke-width + adding a clip-path.
//   We remove clip-paths (v2.5). Without a clip-path the doubled stroke bleeds 0.5dp
//   outside the shape boundary and looks visually heavier at larger sizes.
//   Fix: for ALL stroke-only closed shapes (rect/circle/ellipse AND closed <path>),
//   we convert to a filled evenodd "frame" path: outer boundary + inner boundary
//   inset by 1dp. This perfectly replicates 1dp inside stroke with no outward bleed,
//   and the visual weight is identical at 16, 24 and 32dp because 1 SVG unit = 1dp.
//
// Open paths (lines, polylines) and filled shapes are left as-is with stroke-width="1".
function flattenToCompoundPaths(contentG, s) {
  const SHAPE_TAGS = new Set(['path', 'line', 'circle', 'ellipse', 'rect', 'polyline', 'polygon']);
  // Inside-stroke visual weight in dp. With viewBox/width/height set to the canvas size,
  // 1 SVG unit = 1dp, so SW=1 is always 1dp regardless of output size.
  const SW = 1;

  // Default stroke to 'none' — do NOT fall back to 'currentColor'.
  const cgStroke      = contentG.getAttribute('stroke')            || 'none';
  const cgFill        = contentG.getAttribute('fill')              || 'none';
  const cgStrokeWidth = contentG.getAttribute('stroke-width')      || '1';
  const cgLinecap     = contentG.getAttribute('stroke-linecap')    || '';
  const cgLinejoin    = contentG.getAttribute('stroke-linejoin')   || '';
  const cgMiterlimit  = contentG.getAttribute('stroke-miterlimit') || '';

  function styleVal(node, prop) {
    const sv = node.getAttribute('style') || '';
    const m = sv.match(new RegExp('(?:^|;)\\s*' + prop + '\\s*:\\s*([^;]+)'));
    return m ? m[1].trim() : '';
  }

  // Build the path `d` for the INNER boundary of a closed simple shape inset by SW.
  // Returns '' if the inner shape would collapse to zero or negative size.
  function makeInnerD(node, tag) {
    const f = v => parseFloat(v || '0');
    const tmp = node.ownerDocument.createElementNS('http://www.w3.org/2000/svg', tag);
    if (tag === 'rect') {
      const x = f(node.getAttribute('x')), y = f(node.getAttribute('y'));
      const w = f(node.getAttribute('width')), h = f(node.getAttribute('height'));
      const rxRaw = f(node.getAttribute('rx')), ryRaw = f(node.getAttribute('ry') || node.getAttribute('rx'));
      const iw = w - 2 * SW, ih = h - 2 * SW;
      if (iw <= 0 || ih <= 0) return '';
      tmp.setAttribute('x',      x + SW);
      tmp.setAttribute('y',      y + SW);
      tmp.setAttribute('width',  iw);
      tmp.setAttribute('height', ih);
      tmp.setAttribute('rx', Math.max(rxRaw - SW, 0));
      tmp.setAttribute('ry', Math.max(ryRaw - SW, 0));
    } else if (tag === 'circle') {
      const r = f(node.getAttribute('r'));
      if (r - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('r',  r - SW);
    } else if (tag === 'ellipse') {
      const rx = f(node.getAttribute('rx')), ry = f(node.getAttribute('ry'));
      if (rx - SW <= 0 || ry - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('rx', rx - SW);
      tmp.setAttribute('ry', ry - SW);
    }
    return shapeToPathD(tmp);
  }

  const items = [];
  function collect(node) {
    if (node.nodeType !== 1) return;
    const tag = node.tagName.toLowerCase();
    if (SHAPE_TAGS.has(tag)) {
      const stroke      = node.getAttribute('stroke')            || styleVal(node, 'stroke')            || cgStroke;
      const fill        = node.getAttribute('fill')              || styleVal(node, 'fill')              || cgFill;
      const strokeWidth = node.getAttribute('stroke-width')      || styleVal(node, 'stroke-width')      || cgStrokeWidth;
      const linecap     = node.getAttribute('stroke-linecap')    || styleVal(node, 'stroke-linecap')    || cgLinecap;
      const linejoin    = node.getAttribute('stroke-linejoin')   || styleVal(node, 'stroke-linejoin')   || cgLinejoin;
      const miterlimit  = node.getAttribute('stroke-miterlimit') || styleVal(node, 'stroke-miterlimit') || cgMiterlimit;

      const hasStroke = stroke && stroke !== 'none';
      const hasFill   = fill   && fill   !== 'none';

      // ── Inside-stroke-to-fill conversion ──
      // Closed shapes with stroke only (fill=none) are converted to filled evenodd
      // "frame" paths (outer + inner boundary inset by 1dp). This replicates a 1dp
      // inside stroke with no outward bleed, giving identical visual weight at all sizes.
      const isClosedSimple = tag === 'rect' || tag === 'circle' || tag === 'ellipse';
      const isClosedPathEl = tag === 'path' && isClosedPath(shapeToPathD(node));
      if (hasStroke && !hasFill && (isClosedSimple || isClosedPathEl)) {
        const outerD = shapeToPathD(node);
        if (!outerD) return;
        const innerD = isClosedSimple ? makeInnerD(node, tag) : makeInnerDFromPath(outerD);
        const combinedD = innerD ? outerD + ' ' + innerD : outerD;
        items.push({
          d:           combinedD,
          fill:        stroke,                      // stroke colour → fill colour
          stroke:      'none',
          fillRule:    innerD ? 'evenodd' : 'nonzero',
          strokeWidth: '0',
          linecap, linejoin, miterlimit,
        });
        return;
      }

      // ── Normal shape ── (open paths, filled shapes, complex closed paths)
      const d = shapeToPathD(node);
      if (!d) return;
      items.push({
        d,
        stroke, fill, strokeWidth,
        fillRule: 'nonzero',
        linecap, linejoin, miterlimit,
      });
    } else {
      Array.from(node.childNodes).forEach(collect);
    }
  }
  Array.from(contentG.childNodes).forEach(collect);
  if (!items.length) return;

  // Group by full style signature (fillRule included so frame paths don't merge with other fills)
  const groups = new Map();
  items.forEach(it => {
    const key = [it.stroke, it.fill, it.strokeWidth, it.linecap, it.linejoin, it.miterlimit, it.fillRule].join('|');
    if (!groups.has(key)) groups.set(key, { it, dParts: [] });
    groups.get(key).dParts.push(it.d);
  });

  while (contentG.firstChild) contentG.removeChild(contentG.firstChild);
  ['stroke', 'fill', 'stroke-width', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit'].forEach(a =>
    contentG.removeAttribute(a));

  const ns = 'http://www.w3.org/2000/svg';
  groups.forEach(({ it, dParts }) => {
    const p = contentG.ownerDocument.createElementNS(ns, 'path');
    p.setAttribute('d', dParts.join(' '));
    if (it.fillRule === 'evenodd') p.setAttribute('fill-rule', 'evenodd');
    p.setAttribute('fill', it.fill || 'none');
    if (it.stroke && it.stroke !== 'none') {
      // Open-path strokes (lines, open paths): always 1dp at every output size.
      p.setAttribute('stroke',       it.stroke);
      p.setAttribute('stroke-width', '1');
      if (it.linecap)    p.setAttribute('stroke-linecap',    it.linecap);
      if (it.linejoin)   p.setAttribute('stroke-linejoin',   it.linejoin);
      if (it.miterlimit) p.setAttribute('stroke-miterlimit', it.miterlimit);
    } else {
      p.setAttribute('stroke', 'none');
    }
    contentG.appendChild(p);
  });
}

function normalizeSVG(svgString, keyline, size) {
  const { doc, root: svgEl } = parseSVGString(svgString);
  const serializer = new XMLSerializer();

  // Ensure viewBox
  ensureViewBox(svgEl);

  // Get content bounding box via sandbox render
  const bboxData = getContentBBox(svgString);
  if (!bboxData) throw new Error('Could not compute bounding box');

  const { x: bx, y: by, width: bw, height: bh, vbInfo } = bboxData;

  // Keyline dimensions for target size
  const kl = SPEC.keylines[size][keyline];

  // Scale factor: fit content bounding box into keyline bounds.
  const sx = kl.w / bw;
  const sy = kl.h / bh;
  const s = Math.min(sx, sy);

  // Translation to centre content in the canvas
  const tx = size / 2 - (bx + bw / 2) * s;
  const ty = size / 2 - (by + bh / 2) * s;

  // ── Build output SVG ──
  // Re-parse the original SVG cleanly
  const { doc: outDoc, root: outSvg } = parseSVGString(svgString);

  // viewBox = "0 0 size size" — 1 SVG unit = 1dp exactly.
  // All path coordinates will be flattened into this dp space,
  // so stroke-width="1" = 1dp directly. No renderer ambiguity.
  outSvg.setAttribute('viewBox', `0 0 ${size} ${size}`);
  outSvg.setAttribute('width', String(size));
  outSvg.setAttribute('height', String(size));
  outSvg.setAttribute('fill', 'none');
  outSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  outSvg.removeAttribute('class');
  outSvg.removeAttribute('style');
  outSvg.removeAttribute('preserveAspectRatio');

  // Collect non-defs children to move into content group
  const childrenToWrap = Array.from(outSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  // Content group — no transform; coordinates are flattened into dp space below.
  const contentG = outDoc.createElementNS('http://www.w3.org/2000/svg', 'g');
  contentG.setAttribute('id', 'icon-content');

  childrenToWrap.forEach(child => contentG.appendChild(child));

  // Remove <style> blocks — they contain CSS width/height/stroke-width rules that
  // override our normalized presentation attributes in Figma and browsers.
  // All styling is now applied directly as SVG attributes, so <style> is not needed.
  contentG.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  // ── Move stroke presentation attributes from root SVG → contentG ──
  // Many icon SVGs put stroke="currentColor" stroke-width="1.5" fill="none" on root <svg>.
  // We move ALL of these to contentG so flattenToCompoundPaths can read the effective values
  // and set them explicitly on each merged path (breaking the inheritance chain cleanly).
  const STROKE_INHERIT_ATTRS = [
    'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
    'stroke-miterlimit', 'stroke-opacity', 'stroke-dasharray', 'stroke-dashoffset',
  ];
  STROKE_INHERIT_ATTRS.forEach(attr => {
    const val = outSvg.getAttribute(attr);
    if (val && !contentG.hasAttribute(attr)) contentG.setAttribute(attr, val);
    outSvg.removeAttribute(attr);
  });

  // Flatten all shape coordinates into dp space using the outer matrix [s,0,0,s,tx,ty].
  // Stroke-width is intentionally NOT changed — the source value is preserved exactly.
  walkFlatten(contentG, [s, 0, 0, s, tx, ty]);

  // Merge all shapes into flat compound paths and remove all <g> wrappers.
  // Result: icon-content → 1–N <path> elements. Figma shows a clean flat layer structure.
  // s is passed so stroke-width is scaled proportionally with the coordinate transform.
  flattenToCompoundPaths(contentG, s);

  outSvg.appendChild(contentG);

  // Remove ALL <style> elements from the entire output SVG — including any inside <defs>.
  // CSS width/height/stroke-width rules override SVG presentation attributes and cause
  // Figma to create the wrong frame size, which scales the content and makes stroke-width="1"
  // appear as a completely different value. The v2.4 fix only removed <style> from contentG;
  // this catches any <style> that survived inside <defs>.
  outSvg.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  // Remove all clip-path attributes and <clipPath> definitions.
  outSvg.querySelectorAll('[clip-path]').forEach(el => el.removeAttribute('clip-path'));
  outSvg.querySelectorAll('clipPath').forEach(el => el.parentNode.removeChild(el));

  return serializer.serializeToString(outSvg);
}

// ═══════════════════════════════════════════════════════════
// KEYLINE OVERLAY SVG (for the normalized preview)
// ═══════════════════════════════════════════════════════════

function buildKeylineOverlay(keyline, size) {
  const kl = SPEC.keylines[size][keyline];
  const pad = SPEC.padding[size];
  const color = SPEC.keylineColors[keyline];
  const cx = size / 2;
  const cy = size / 2;

  // Safe zone
  const szX = pad;
  const szY = pad;
  const szW = size - pad * 2;
  const szH = size - pad * 2;

  let keylineShape = '';
  if (keyline === 'circle') {
    const r = kl.w / 2;
    keylineShape = `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}14" stroke="${color}" stroke-width="0.25" stroke-dasharray="0.7 0.4"/>`;
  } else {
    const klX = cx - kl.w / 2;
    const klY = cy - kl.h / 2;
    keylineShape = `<rect x="${klX}" y="${klY}" width="${kl.w}" height="${kl.h}" rx="0.5" fill="${color}14" stroke="${color}" stroke-width="0.25" stroke-dasharray="0.7 0.4"/>`;
  }

  return `
    <rect x="0.1" y="0.1" width="${size - 0.2}" height="${size - 0.2}" fill="none" stroke="#c0c0c0" stroke-width="0.15"/>
    <rect x="${szX}" y="${szY}" width="${szW}" height="${szH}" fill="none" stroke="#bbb" stroke-width="0.12" stroke-dasharray="0.5 0.4"/>
    ${keylineShape}
  `;
}

// ═══════════════════════════════════════════════════════════
// PROCESSING QUEUE
// ═══════════════════════════════════════════════════════════

async function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = () => reject(new Error('Could not read file'));
    reader.readAsText(file);
  });
}

async function loadFileForProcessing(file) {
  const panel = document.getElementById('process-panel');
  const errDiv = document.getElementById('proc-error');
  errDiv.classList.remove('visible');

  try {
    const svgString = await readFileAsText(file);
    // Validate
    parseSVGString(svgString);

    state.currentRawSvg = svgString;

    // Show original preview
    const originalPreview = document.getElementById('original-preview');
    originalPreview.innerHTML = '';
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = svgString;
    const svgEl = tempDiv.querySelector('svg');
    if (svgEl) {
      svgEl.removeAttribute('width');
      svgEl.removeAttribute('height');
      svgEl.style.width = '65%';
      svgEl.style.height = '65%';
      originalPreview.appendChild(svgEl);
    }

    // Get bbox and detect keyline
    const bbox = getContentBBox(svgString);
    const detected = detectKeyline(svgString, bbox);
    state.currentKeyline = detected;
    state.currentSize = 24;

    // Populate UI
    const filename = file.name.replace('.svg', '');
    document.getElementById('icon-name').value = filename;
    document.getElementById('panel-filename').textContent = filename;

    // Bbox info
    if (bbox) {
      const ratio = (bbox.width / bbox.height).toFixed(2);
      document.getElementById('original-info').textContent =
        `${bbox.width.toFixed(1)} × ${bbox.height.toFixed(1)} (ratio ${ratio})`;
    }

    // Set keyline buttons
    updateKeylineButtons(detected);
    updateSizeButtons(24);

    // Normalize + preview
    await updateNormalizedPreview();

    panel.classList.add('visible');
    document.getElementById('save-btn').disabled = false;

  } catch (e) {
    errDiv.textContent = e.message || 'Could not process SVG';
    errDiv.classList.add('visible');
    panel.classList.add('visible');
    document.getElementById('save-btn').disabled = true;
    console.error(e);
  }
}

async function updateNormalizedPreview() {
  if (!state.currentRawSvg) return;

  const normLayer = document.getElementById('norm-icon-layer');
  const overlayEl = document.getElementById('norm-overlay-layer');
  const normInfo = document.getElementById('norm-info');

  try {
    const normalized = normalizeSVG(state.currentRawSvg, state.currentKeyline, state.currentSize);
    state.currentNormalizedSvg = normalized;

    // Show normalized icon
    normLayer.innerHTML = normalized;
    const normSvg = normLayer.querySelector('svg');
    if (normSvg) {
      normSvg.removeAttribute('width');
      normSvg.removeAttribute('height');
      normSvg.style.width = '100%';
      normSvg.style.height = '100%';
    }

    // Update overlay
    overlayEl.setAttribute('viewBox', `0 0 ${state.currentSize} ${state.currentSize}`);
    overlayEl.innerHTML = buildKeylineOverlay(state.currentKeyline, state.currentSize);
    overlayEl.style.opacity = state.overlayVisible ? '1' : '0';

    // Update info
    const kl = SPEC.keylines[state.currentSize][state.currentKeyline];
    const klLabel = state.currentKeyline === 'circle'
      ? `${kl.w}dp ⌀`
      : `${kl.w}×${kl.h}dp`;
    normInfo.textContent = `· ${klLabel} keyline · ${state.currentSize}dp canvas`;

    // Update size strip
    renderSizeStrip(normalized);

  } catch (e) {
    const errDiv = document.getElementById('proc-error');
    errDiv.textContent = 'Normalization error: ' + e.message;
    errDiv.classList.add('visible');
    state.currentNormalizedSvg = null;
    document.getElementById('save-btn').disabled = true;
    console.error(e);
  }
}

function renderSizeStrip(normalizedSvg) {
  const strip = document.getElementById('size-strip');
  const SIZES = [16, 24, 32, 48, 64];

  // Parse once and reuse the SVG, only changing display dimensions
  const parser = new DOMParser();
  const basePx = SIZES[0];

  strip.innerHTML = '';
  SIZES.forEach(px => {
    const doc = parser.parseFromString(normalizedSvg, 'image/svg+xml');
    const svg = doc.documentElement;
    // Set explicit px dimensions; keep viewBox so it renders correctly
    svg.setAttribute('width', px);
    svg.setAttribute('height', px);
    svg.style.display = 'block';
    svg.style.flexShrink = '0';

    const frame = document.createElement('div');
    frame.className = 'icon-frame';
    frame.style.width = px + 'px';
    frame.style.height = px + 'px';
    frame.appendChild(svg);

    const label = document.createElement('span');
    label.textContent = px + 'px';

    const demo = document.createElement('div');
    demo.className = 'size-demo';
    demo.appendChild(frame);
    demo.appendChild(label);
    strip.appendChild(demo);
  });
}

function updateKeylineButtons(selected) {
  document.querySelectorAll('.keyline-btn').forEach(btn => {
    const kl = btn.dataset.keyline;
    btn.classList.remove('active', 'auto-detected');
    if (kl === selected) {
      btn.classList.add('active', 'auto-detected');
    }
  });
}

function updateSizeButtons(selected) {
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.size) === selected);
  });
}

function processNextInQueue() {
  const queueBar = document.getElementById('queue-bar');
  const queue = state.queue;

  if (state.queueIndex >= queue.length) {
    // Done
    queueBar.classList.remove('visible');
    return;
  }

  // Update queue bar
  document.getElementById('queue-text').textContent =
    `Processing ${state.queueIndex + 1} of ${queue.length}`;
  renderQueueDots();
  queueBar.classList.add('visible');

  loadFileForProcessing(queue[state.queueIndex]);
}

function renderQueueDots() {
  const container = document.getElementById('queue-dots');
  const queue = state.queue;
  if (queue.length <= 1) { container.innerHTML = ''; return; }

  container.innerHTML = queue.slice(0, Math.min(queue.length, 12)).map((_, i) => {
    let cls = 'q-dot';
    if (i < state.queueIndex) cls += ' done';
    if (i === state.queueIndex) cls += ' active';
    return `<div class="${cls}"></div>`;
  }).join('');
}

// ═══════════════════════════════════════════════════════════
// LIBRARY RENDERING
// ═══════════════════════════════════════════════════════════

function renderLibrary() {
  const grid = document.getElementById('library-grid');
  const emptyState = document.getElementById('empty-state');
  const count = document.getElementById('library-count');
  const exportBtn = document.getElementById('export-zip-btn');

  const filtered = state.filter === 'all'
    ? state.library
    : state.library.filter(ic => ic.keyline === state.filter);

  count.textContent = `(${state.library.length} icon${state.library.length !== 1 ? 's' : ''})`;
  exportBtn.disabled = state.library.length === 0;

  if (filtered.length === 0) {
    grid.innerHTML = '';
    emptyState.classList.add('visible');
    const mainP = emptyState.querySelector('p');
    const hintP = emptyState.querySelector('.empty-hint');
    if (state.library.length === 0) {
      if (mainP) mainP.textContent = 'No icons yet';
      if (hintP) hintP.textContent = 'Drop SVG files above to get started';
    } else {
      if (mainP) mainP.textContent = `No ${state.filter} icons in library`;
      if (hintP) hintP.textContent = 'Try a different filter above';
    }
    return;
  }

  emptyState.classList.remove('visible');

  grid.innerHTML = filtered.map(icon => {
    const thumbSvg = icon.svgString
      .replace(/width="\d+"/, 'width="38"')
      .replace(/height="\d+"/, 'height="38"');
    const isSelected = state.selectedIds.has(icon.id);

    return `
      <div class="icon-card${isSelected ? ' selected' : ''}" data-id="${icon.id}">
        <button class="card-checkbox${isSelected ? ' checked' : ''}"
          onclick="toggleSelection(event,'${icon.id}')"
          title="Select for batch download">
          <svg width="10" height="8" viewBox="0 0 10 8" fill="none">
            <path d="M1 4l3 3 5-6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="card-actions">
          <button class="card-action-btn" onclick="downloadIcon('${icon.id}')" title="Download all 3 sizes as ZIP">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
              <path d="M6 1v7M3 5l3 3 3-3M1 9v1a1 1 0 001 1h8a1 1 0 001-1V9" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="card-action-btn delete" onclick="confirmDelete('${icon.id}')" title="Delete">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
              <path d="M2 3h8M5 1h2M4 3v7M8 3v7M3 3l.5 7h5l.5-7" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
        <div class="icon-thumb">${thumbSvg}</div>
        <div class="icon-card-name">${escapeHTML(icon.name)}</div>
        <span class="keyline-badge ${icon.keyline}">${icon.keyline}</span>
        <span class="size-label">${icon.size}dp</span>
      </div>
    `;
  }).join('');
}

function escapeHTML(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ═══════════════════════════════════════════════════════════
// DOWNLOAD + EXPORT
// ═══════════════════════════════════════════════════════════

function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function addAllSizesToZip(zip, icon) {
  // Re-normalize at all 3 sizes from the original SVG (or fallback to stored normalized)
  const source = icon.originalSvg || icon.svgString;
  [16, 24, 32].forEach(sz => {
    try {
      const svg = normalizeSVG(source, icon.keyline, sz);
      zip.file(`${icon.name}/${icon.name}_${sz}dp.svg`, svg);
    } catch (e) {
      console.warn(`Could not generate ${sz}dp for ${icon.name}:`, e);
    }
  });
}

async function downloadIcon(id) {
  const icon = state.library.find(ic => ic.id === id);
  if (!icon) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded', 'error');
    return;
  }
  const zip = new JSZip();
  addAllSizesToZip(zip, icon);
  const blob = await zip.generateAsync({ type: 'blob' });
  triggerDownload(blob, `${icon.name}_${icon.keyline}.zip`);
  showToast(`"${icon.name}" downloaded — 3 sizes`);
}

async function exportAllAsZip() {
  if (state.library.length === 0) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded. Check your internet connection.', 'error');
    return;
  }

  const zip = new JSZip();
  state.library.forEach(icon => addAllSizesToZip(zip, icon));

  const btn = document.getElementById('export-zip-btn');
  btn.textContent = 'Generating…';
  btn.disabled = true;

  try {
    const blob = await zip.generateAsync({ type: 'blob' });
    triggerDownload(blob, `icons_${new Date().toISOString().slice(0,10)}.zip`);
    showToast(`Exported ${state.library.length} icons (3 sizes each)`);
  } catch (e) {
    showToast('Export failed: ' + e.message, 'error');
  } finally {
    btn.textContent = 'Export all as ZIP';
    btn.disabled = state.library.length === 0;
  }}

function confirmDelete(id) {
  const icon = state.library.find(ic => ic.id === id);
  if (!icon) return;
  if (confirm(`Delete "${icon.name}"?`)) {
    state.selectedIds.delete(id);
    updateSelectionBar();
    deleteFromLibrary(id);
  }
}

// ── Overlay toggle ──
function setupOverlayToggle() {
  document.getElementById('overlay-toggle').addEventListener('click', () => {
    state.overlayVisible = !state.overlayVisible;
    const btn = document.getElementById('overlay-toggle');
    btn.classList.toggle('active', state.overlayVisible);
    document.getElementById('norm-overlay-layer').style.opacity = state.overlayVisible ? '1' : '0';
  });
}

// ── Selection + batch download ──
function toggleSelection(event, id) {
  event.stopPropagation();
  if (state.selectedIds.has(id)) {
    state.selectedIds.delete(id);
  } else {
    state.selectedIds.add(id);
  }
  // Update just this card without full re-render
  const card = document.querySelector(`.icon-card[data-id="${id}"]`);
  if (card) {
    const isNowSelected = state.selectedIds.has(id);
    card.classList.toggle('selected', isNowSelected);
    const cb = card.querySelector('.card-checkbox');
    if (cb) cb.classList.toggle('checked', isNowSelected);
  }
  updateSelectionBar();
}

function updateSelectionBar() {
  const bar = document.getElementById('selection-bar');
  const count = state.selectedIds.size;
  if (count === 0) {
    bar.classList.remove('visible');
  } else {
    bar.classList.add('visible');
    document.getElementById('sel-count').textContent =
      `${count} icon${count !== 1 ? 's' : ''} selected`;
  }
}

function clearSelection() {
  state.selectedIds.clear();
  document.querySelectorAll('.icon-card.selected').forEach(card => {
    card.classList.remove('selected');
    const cb = card.querySelector('.card-checkbox');
    if (cb) cb.classList.remove('checked');
  });
  updateSelectionBar();
}

async function downloadSelected() {
  if (state.selectedIds.size === 0) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded', 'error');
    return;
  }
  const btn = document.getElementById('sel-download-btn');
  btn.textContent = 'Generating…';
  btn.disabled = true;

  try {
    const zip = new JSZip();
    const ids = Array.from(state.selectedIds);
    ids.forEach(id => {
      const icon = state.library.find(ic => ic.id === id);
      if (icon) addAllSizesToZip(zip, icon);
    });
    const blob = await zip.generateAsync({ type: 'blob' });
    triggerDownload(blob, `icons_selected_${new Date().toISOString().slice(0,10)}.zip`);
    showToast(`Downloaded ${ids.length} icon${ids.length !== 1 ? 's' : ''} (3 sizes each)`);
    clearSelection();
  } catch (e) {
    showToast('Download failed: ' + e.message, 'error');
  } finally {
    btn.textContent = '↓ Download (all 3 sizes)';
    btn.disabled = false;
  }
}

function setupSelectionBar() {
  document.getElementById('sel-download-btn').addEventListener('click', downloadSelected);
  document.getElementById('sel-clear-btn').addEventListener('click', clearSelection);
}

// ═══════════════════════════════════════════════════════════
// TOAST
// ═══════════════════════════════════════════════════════════

let toastTimeout;
function showToast(msg, type = 'default') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = type !== 'default' ? type : '';
  el.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => el.classList.remove('show'), 2800);
}

// ═══════════════════════════════════════════════════════════
// EVENT WIRING
// ═══════════════════════════════════════════════════════════

function setupUploadZone() {
  const dropArea = document.getElementById('drop-area');
  const fileInput = document.getElementById('file-input');
  const browseLink = document.getElementById('browse-link');

  browseLink.addEventListener('click', () => fileInput.click());
  dropArea.addEventListener('click', e => {
    if (e.target !== browseLink) fileInput.click();
  });

  fileInput.addEventListener('change', e => {
    handleFiles(Array.from(e.target.files));
    fileInput.value = ''; // reset so same file can be re-uploaded
  });

  dropArea.addEventListener('dragover', e => {
    e.preventDefault();
    dropArea.classList.add('drag-over');
  });
  dropArea.addEventListener('dragleave', () => dropArea.classList.remove('drag-over'));
  dropArea.addEventListener('drop', e => {
    e.preventDefault();
    dropArea.classList.remove('drag-over');
    const svgFiles = Array.from(e.dataTransfer.files).filter(f =>
      f.name.endsWith('.svg') || f.type === 'image/svg+xml'
    );
    if (svgFiles.length === 0) {
      showToast('Please drop SVG files', 'error');
      return;
    }
    handleFiles(svgFiles);
  });
}

function handleFiles(files) {
  const svgFiles = files.filter(f => f.name.endsWith('.svg') || f.type === 'image/svg+xml');
  if (svgFiles.length === 0) {
    showToast('No SVG files found', 'error');
    return;
  }
  state.queue = svgFiles;
  state.queueIndex = 0;
  processNextInQueue();
}

function setupKeylineButtons() {
  document.querySelectorAll('.keyline-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const kl = btn.dataset.keyline;
      state.currentKeyline = kl;
      // Remove auto-detected badge from all, mark selected
      document.querySelectorAll('.keyline-btn').forEach(b => {
        b.classList.remove('active', 'auto-detected');
      });
      btn.classList.add('active');
      await updateNormalizedPreview();
    });
  });
}

function setupSizeButtons() {
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      state.currentSize = parseInt(btn.dataset.size);
      updateSizeButtons(state.currentSize);
      await updateNormalizedPreview();
    });
  });
}

function setupSaveButton() {
  document.getElementById('save-btn').addEventListener('click', () => {
    if (!state.currentNormalizedSvg) return;

    const name = (document.getElementById('icon-name').value || 'icon').trim();
    const icon = {
      id: 'icon_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7),
      name,
      keyline: state.currentKeyline,
      size: state.currentSize,
      svgString: state.currentNormalizedSvg,
      originalSvg: state.currentRawSvg,   // stored for multi-size re-export
      createdAt: new Date().toISOString(),
      animations: [], // v2 placeholder
    };

    addToLibrary(icon);
    renderLibrary();
    showToast(`"${name}" saved to library`, 'success');

    // Advance queue
    state.queueIndex++;
    if (state.queueIndex < state.queue.length) {
      processNextInQueue();
    } else {
      document.getElementById('queue-bar').classList.remove('visible');
      document.getElementById('process-panel').classList.remove('visible');
    }
  });
}

function setupSkipButton() {
  document.getElementById('skip-btn').addEventListener('click', () => {
    state.queueIndex++;
    document.getElementById('proc-error').classList.remove('visible');
    if (state.queueIndex < state.queue.length) {
      processNextInQueue();
    } else {
      document.getElementById('queue-bar').classList.remove('visible');
      document.getElementById('process-panel').classList.remove('visible');
    }
  });
}

function setupFilterButtons() {
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.filter = btn.dataset.filter;
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderLibrary();
    });
  });
}

function setupSpecToggle() {
  const btn = document.getElementById('spec-toggle-btn');
  const panel = document.getElementById('spec-panel');
  btn.addEventListener('click', () => {
    const isOpen = panel.classList.toggle('open');
    btn.classList.toggle('open', isOpen);
    btn.querySelector('span') && (btn.querySelector('span').textContent = isOpen ? 'Hide spec' : 'Spec reference');
  });
}

function setupExportButton() {
  document.getElementById('export-zip-btn').addEventListener('click', exportAllAsZip);
}

// ═══════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════

function init() {
  loadLibrary();
  setupUploadZone();
  setupKeylineButtons();
  setupSizeButtons();
  setupSaveButton();
  setupSkipButton();
  setupFilterButtons();
  setupSpecToggle();
  setupExportButton();
  setupOverlayToggle();
  setupSelectionBar();
  renderLibrary();
}

document.addEventListener('DOMContentLoaded', init);

// ═══════════════════════════════════════════════════════════
// ANIMATIONS
// ═══════════════════════════════════════════════════════════

// Stagger card entrance when library grid re-renders
function animateCards() {
  const cards = document.querySelectorAll('#library-grid .icon-card');
  cards.forEach((card, i) => {
    card.classList.remove('card-anim');
    void card.offsetWidth; // force reflow
    card.style.animationDelay = (i * 45) + 'ms';
    card.classList.add('card-anim');
  });
}

// Patch renderLibrary to call animateCards after render
const _origRenderLibrary = renderLibrary;
renderLibrary = function() {
  _origRenderLibrary.apply(this, arguments);
  requestAnimationFrame(animateCards);
};

// Upload icon: scale to 1 on drop-area click interaction
document.addEventListener('DOMContentLoaded', () => {
  const dropArea = document.getElementById('drop-area');
  if (dropArea) {
    dropArea.addEventListener('dragenter', () => dropArea.classList.add('drag-over'));
    dropArea.addEventListener('dragleave', () => dropArea.classList.remove('drag-over'));
    dropArea.addEventListener('drop', () => setTimeout(() => dropArea.classList.remove('drag-over'), 200));
  }
});
</script>
</body>
</html>
