<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Icon Safe Area Normalizer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f6f9fc;
  --surface: #ffffff;
  --surface-2: #f0f4f8;
  --primary: #0a2540;
  --secondary: #425466;
  --tertiary: #8898aa;
  --border: #e3e8ee;
  --border-mid: #c1c9d2;
  --accent: #635BFF;
  --accent-hover: #5147d5;
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-serif: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --color-circle: #635BFF;
  --color-square: #0DBD8B;
  --color-vertical: #F5A623;
  --color-horizontal: #ED5F74;
  --success: #0DBD8B;
  --error: #DF1B41;
  --shadow-sm: 0 1px 3px 0 rgba(0,0,0,0.04), 0 1px 2px -1px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.06), 0 2px 4px -2px rgba(0,0,0,0.05);
  --shadow-lg: 0 10px 25px -3px rgba(0,0,0,0.08), 0 4px 10px -4px rgba(0,0,0,0.04);
}

body {
  font-family: var(--font);
  background: var(--bg);
  color: var(--primary);
  line-height: 1.5;
  min-height: 100vh;
  font-size: 14px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#svg-sandbox {
  position: absolute; left: -9999px; top: -9999px;
  visibility: hidden; pointer-events: none; width: 200px; height: 200px;
}

#app { max-width: 1080px; margin: 0 auto; padding: 0 40px 80px; }

header {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding: 56px 0 32px;
  margin-bottom: 40px;
  gap: 24px;
}
.header-line {
  display: block;
  height: 2px;
  background: linear-gradient(90deg, var(--accent), #ed5f74);
  width: 0;
  margin-bottom: 20px;
  border-radius: 1px;
}
header h1 {
  font-family: var(--font);
  font-size: 34px;
  font-weight: 700;
  letter-spacing: -0.8px;
  line-height: 1.15;
  color: var(--primary);
}
.v-badge {
  font-family: var(--font);
  display: inline-block;
  font-size: 10px; font-weight: 600;
  color: var(--accent); letter-spacing: 0.3px;
  background: rgba(99,91,255,0.08);
  border: 1px solid rgba(99,91,255,0.15);
  border-radius: 20px;
  padding: 2px 8px;
  margin-left: 10px;
  vertical-align: middle;
  position: relative; top: -3px;
}
header div p { font-size: 13px; color: var(--secondary); margin-top: 8px; letter-spacing: 0; }

/* Spec toggle */
#spec-toggle-btn {
  padding: 8px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: var(--font);
  font-size: 12px; font-weight: 500; color: var(--secondary);
  cursor: pointer; display: flex; align-items: center; gap: 6px;
  transition: all 0.2s ease; box-shadow: var(--shadow-sm); flex-shrink: 0;
}
#spec-toggle-btn:hover { border-color: var(--border-mid); color: var(--primary); box-shadow: var(--shadow-md); }
#spec-toggle-btn svg { transition: transform 0.2s; }
#spec-toggle-btn.open svg { transform: rotate(180deg); }

.plugin-dl-btn {
  padding: 8px 14px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-family: var(--font);
  font-size: 12px; font-weight: 500; color: var(--secondary);
  cursor: pointer; display: flex; align-items: center; gap: 6px;
  transition: all 0.2s ease; box-shadow: var(--shadow-sm);
  text-decoration: none; white-space: nowrap;
}
.plugin-dl-btn:hover { border-color: var(--accent); color: var(--accent); box-shadow: var(--shadow-md); }

#spec-panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  margin-bottom: 24px; overflow: hidden; display: none;
  box-shadow: var(--shadow-sm);
}
#spec-panel.open { display: block; }

.spec-inner { padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }

.spec-table-wrap h3 {
  font-size: 11px; font-weight: 600; color: var(--tertiary);
  margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.8px;
}
.spec-table { width: 100%; border-collapse: collapse; font-size: 12px; }
.spec-table th {
  background: var(--surface-2); color: var(--secondary);
  font-weight: 600; padding: 7px 12px; text-align: left;
  font-size: 11px; letter-spacing: 0.2px;
}
.spec-table td { padding: 7px 12px; border-bottom: 1px solid var(--border); color: var(--primary); }
.spec-table tr:last-child td { border-bottom: none; }

/* Upload zone */
#upload-zone { margin-bottom: 20px; }
#drop-area {
  border: 2px dashed var(--border);
  border-radius: var(--radius-lg);
  background: var(--surface);
  padding: 64px 24px;
  text-align: center; cursor: pointer;
  transition: all 0.25s ease;
}
#drop-area:hover, #drop-area.drag-over {
  border-color: var(--accent);
  background: rgba(99,91,255,0.02);
}
#drop-area .upload-icon { margin-bottom: 16px; color: var(--tertiary); }
#drop-area .upload-label { font-size: 15px; font-weight: 500; color: var(--primary); margin-bottom: 5px; }
#drop-area .upload-hint { font-size: 12px; color: var(--secondary); }
#browse-link { color: var(--accent); font-weight: 600; cursor: pointer; }

/* Queue bar */
#queue-bar {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-md); padding: 12px 16px;
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 16px; display: none;
  box-shadow: var(--shadow-sm);
}
#queue-bar.visible { display: flex; }
.queue-left { display: flex; align-items: center; gap: 12px; }
#queue-text { font-size: 13px; font-weight: 500; }
#queue-dots { display: flex; gap: 4px; }
.q-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--border); transition: background 0.2s; }
.q-dot.done { background: var(--success); }
.q-dot.active { background: var(--accent); }
#skip-btn {
  font-size: 12px; color: var(--secondary);
  background: none; border: none; cursor: pointer;
  font-family: var(--font); padding: 4px 10px;
  border-radius: var(--radius-sm); transition: all 0.15s;
}
#skip-btn:hover { background: var(--surface-2); color: var(--primary); }

/* Processing panel */
#process-panel {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-lg); padding: 28px;
  margin-bottom: 20px; display: none;
  box-shadow: var(--shadow-md);
}
#process-panel.visible { display: block; }
.panel-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 28px; }
.panel-header h2 { font-family: var(--font); font-size: 20px; font-weight: 650; letter-spacing: -0.3px; }
.panel-inner { display: grid; grid-template-columns: 1fr 240px 1fr; gap: 32px; align-items: start; }

.preview-col h3 {
  font-size: 10px; font-weight: 600; color: var(--tertiary);
  text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 10px;
}
.preview-box {
  aspect-ratio: 1; max-width: 220px;
  background: var(--surface-2); border-radius: var(--radius-md);
  border: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center;
  overflow: hidden; position: relative;
}
.preview-box svg { width: 60%; height: 60%; }
.preview-box img { width: 60%; height: 60%; object-fit: contain; }

#norm-preview-wrap {
  aspect-ratio: 1; max-width: 220px;
  background: var(--surface-2); border-radius: var(--radius-md);
  border: 1px solid var(--border); position: relative; overflow: hidden;
}
#norm-icon-layer { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }
#norm-icon-layer svg { width: 100%; height: 100%; }
#norm-overlay-layer { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

/* Size strip */
#size-strip {
  display: flex; align-items: flex-end; gap: 14px;
  margin-top: 12px; padding: 12px;
  background: var(--surface-2); border-radius: var(--radius-sm);
  border: 1px solid var(--border); flex-wrap: wrap;
}
.size-demo { display: flex; flex-direction: column; align-items: center; gap: 5px; }
.size-demo span { font-size: 9px; color: var(--tertiary); letter-spacing: 0.2px; }
.size-demo .icon-frame {
  background: white; border: 1px solid var(--border); border-radius: 2px;
  display: flex; align-items: center; justify-content: center; flex-shrink: 0;
}
.size-demo .icon-frame svg { display: block; }

/* Controls column */
.controls-col { display: flex; flex-direction: column; gap: 20px; }
.control-group { display: flex; flex-direction: column; gap: 7px; }
.control-group label {
  font-size: 10px; font-weight: 600; color: var(--tertiary);
  text-transform: uppercase; letter-spacing: 0.8px;
}
#icon-name {
  width: 100%; padding: 9px 12px;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  font-family: var(--font); font-size: 13px; color: var(--primary);
  background: white; outline: none;
  transition: border-color 0.15s, box-shadow 0.15s;
}
#icon-name:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(99,91,255,0.12); }

/* Keyline buttons */
#keyline-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.keyline-btn {
  display: flex; flex-direction: column; align-items: center; gap: 5px;
  padding: 10px 6px; border: 1px solid var(--border);
  border-radius: var(--radius-md); background: var(--surface);
  cursor: pointer; transition: all 0.2s ease;
  font-family: var(--font); position: relative;
}
.keyline-btn[data-keyline="circle"]  { color: var(--color-circle); }
.keyline-btn[data-keyline="square"]  { color: var(--color-square); }
.keyline-btn[data-keyline="vertical"]    { color: var(--color-vertical); }
.keyline-btn[data-keyline="horizontal"]  { color: var(--color-horizontal); }
.keyline-btn.active[data-keyline="circle"]     { border-color: var(--color-circle);     background: rgba(99,91,255,0.04);  box-shadow: 0 0 0 2px rgba(99,91,255,0.12); }
.keyline-btn.active[data-keyline="square"]     { border-color: var(--color-square);     background: rgba(13,189,139,0.04); box-shadow: 0 0 0 2px rgba(13,189,139,0.12); }
.keyline-btn.active[data-keyline="vertical"]   { border-color: var(--color-vertical);   background: rgba(245,166,35,0.04); box-shadow: 0 0 0 2px rgba(245,166,35,0.12); }
.keyline-btn.active[data-keyline="horizontal"] { border-color: var(--color-horizontal); background: rgba(237,95,116,0.04); box-shadow: 0 0 0 2px rgba(237,95,116,0.12); }
.keyline-btn .kl-shape { width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; }
.keyline-btn .kl-label { font-size: 9px; font-weight: 600; text-align: center; text-transform: uppercase; letter-spacing: 0.3px; }
.auto-badge {
  position: absolute; top: 4px; right: 4px;
  font-size: 7px; font-weight: 700; letter-spacing: 0.3px;
  background: var(--accent); color: white;
  padding: 1px 5px; border-radius: 20px; opacity: 0; transition: opacity 0.15s;
}
.keyline-btn.auto-detected .auto-badge { opacity: 1; }

/* Size buttons */
#size-buttons { display: flex; gap: 5px; }
.size-btn {
  flex: 1; padding: 8px 4px;
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  background: var(--surface); font-family: var(--font);
  font-size: 12px; font-weight: 500; color: var(--secondary);
  cursor: pointer; transition: all 0.2s ease; text-align: center;
}
.size-btn:hover { border-color: var(--border-mid); color: var(--primary); }
.size-btn.active { border-color: var(--accent); background: var(--accent); color: white; box-shadow: 0 1px 3px rgba(99,91,255,0.3); }

/* Save button */
#save-btn {
  width: 100%; padding: 11px;
  background: var(--accent); color: white; border: none;
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 14px; font-weight: 600; cursor: pointer;
  transition: all 0.2s ease; letter-spacing: -0.1px;
}
#save-btn:hover { background: var(--accent-hover); box-shadow: 0 4px 12px rgba(99,91,255,0.25); transform: translateY(-1px); }
#save-btn:active { transform: translateY(0); }
#save-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

/* Error */
.proc-error {
  background: rgba(223,27,65,0.06); border: 1px solid rgba(223,27,65,0.15);
  border-radius: var(--radius-sm); padding: 10px 12px;
  font-size: 12px; color: var(--error); display: none; font-weight: 500;
}
.proc-error.visible { display: block; }

/* Library */
#library-section {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-lg); padding: 28px;
  box-shadow: var(--shadow-sm);
}
#library-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
#library-header h2 { font-family: var(--font); font-size: 22px; font-weight: 650; letter-spacing: -0.4px; }
#library-count { font-size: 13px; font-weight: 400; color: var(--tertiary); }

#export-zip-btn {
  padding: 8px 16px; background: var(--surface);
  color: var(--secondary); border: 1px solid var(--border);
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s ease;
  box-shadow: var(--shadow-sm);
}
#export-zip-btn:hover { border-color: var(--border-mid); color: var(--primary); box-shadow: var(--shadow-md); }
#export-zip-btn:disabled { opacity: 0.35; cursor: not-allowed; box-shadow: none; }

#filter-bar { display: flex; gap: 6px; margin-bottom: 24px; flex-wrap: wrap; }
.filter-btn {
  padding: 5px 14px; border-radius: 20px;
  border: 1px solid var(--border); background: transparent;
  font-family: var(--font); font-size: 11px; font-weight: 500;
  color: var(--secondary); cursor: pointer; transition: all 0.2s ease;
}
.filter-btn:hover { border-color: var(--border-mid); color: var(--primary); background: var(--surface-2); }
.filter-btn.active { background: var(--accent); border-color: var(--accent); color: white; }

#library-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }

/* Icon card */
.icon-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius-md); padding: 14px 10px 10px;
  display: flex; flex-direction: column; align-items: center; gap: 8px;
  position: relative; cursor: default;
  transition: all 0.2s ease;
}
.icon-card:hover {
  border-color: var(--border-mid);
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}
.icon-card:hover .card-actions { opacity: 1; }
.icon-thumb {
  width: 56px; height: 56px; background: var(--surface-2);
  border-radius: 8px; border: 1px solid var(--border);
  display: flex; align-items: center; justify-content: center;
}
.icon-thumb svg { width: 36px; height: 36px; }
.icon-card-name {
  font-size: 11px; font-weight: 500; color: var(--primary);
  text-align: center; word-break: break-all; max-width: 100%; line-height: 1.3;
}
.keyline-badge {
  font-size: 9px; font-weight: 600; padding: 2px 8px;
  border-radius: 20px; text-transform: uppercase; letter-spacing: 0.4px;
}
.keyline-badge.circle     { background: rgba(99,91,255,0.08);   color: var(--color-circle); }
.keyline-badge.square     { background: rgba(13,189,139,0.08);  color: var(--color-square); }
.keyline-badge.vertical   { background: rgba(245,166,35,0.08);  color: var(--color-vertical); }
.keyline-badge.horizontal { background: rgba(237,95,116,0.08);  color: var(--color-horizontal); }
.size-label { font-size: 9px; color: var(--tertiary); margin-top: -4px; font-weight: 500; }

.card-actions { position: absolute; top: 6px; right: 6px; display: flex; gap: 3px; opacity: 0; transition: opacity 0.2s; }
.card-action-btn {
  width: 24px; height: 24px; border-radius: 5px;
  border: 1px solid var(--border); background: white;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; font-size: 11px; transition: all 0.15s; color: var(--secondary);
  box-shadow: var(--shadow-sm);
}
.card-action-btn:hover { border-color: var(--border-mid); color: var(--primary); }
.card-action-btn.delete:hover { background: rgba(223,27,65,0.06); border-color: rgba(223,27,65,0.3); color: var(--error); }

/* Empty state */
#empty-state { text-align: center; padding: 52px 24px; color: var(--secondary); display: none; }
#empty-state.visible { display: block; }
#empty-state svg { opacity: 1; }
#empty-state p { font-size: 13px; }

/* Toast */
#toast {
  position: fixed; bottom: 28px; left: 50%;
  transform: translateX(-50%) translateY(80px);
  background: var(--primary); color: white;
  padding: 10px 20px; border-radius: 8px;
  font-size: 13px; font-weight: 500;
  box-shadow: var(--shadow-lg);
  transition: transform 0.35s cubic-bezier(0.34,1.56,0.64,1);
  z-index: 100; pointer-events: none; white-space: nowrap;
}
#toast.show { transform: translateX(-50%) translateY(0); }
#toast.success { background: var(--success); }
#toast.error { background: var(--error); }

@media (max-width: 800px) {
  #app { padding: 0 20px 60px; }
  .panel-inner { grid-template-columns: 1fr; }
  .spec-inner { grid-template-columns: 1fr; }
  header h1 { font-size: 26px; }
}

/* ── Keyframes ──────────────────────────────────────────── */
@keyframes fadeUp {
  from { opacity: 0; transform: translateY(20px); }
  to   { opacity: 1; transform: translateY(0); }
}
@keyframes scaleIn {
  from { opacity: 0; transform: scale(0.97) translateY(6px); }
  to   { opacity: 1; transform: scale(1) translateY(0); }
}
@keyframes lineDraw {
  from { width: 0; opacity: 0; }
  to   { width: 100%; opacity: 1; }
}
@keyframes uploadBob {
  0%, 100% { transform: translateY(0); }
  50%       { transform: translateY(-5px); }
}
@keyframes cardIn {
  from { opacity: 0; transform: translateY(8px) scale(0.97); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes pulseDot {
  0%, 100% { opacity: 1; }
  50%       { opacity: 0.4; }
}

/* ── Page load entrance ─────────────────────────────────── */
header         { animation: fadeUp 0.6s cubic-bezier(0.22,1,0.36,1) both; }
#upload-zone   { animation: fadeUp 0.6s 0.08s cubic-bezier(0.22,1,0.36,1) both; }
#library-section { animation: fadeUp 0.6s 0.16s cubic-bezier(0.22,1,0.36,1) both; }

/* ── Header animated line ───────────────────────────────── */
.header-line {
  animation: lineDraw 1s 0.15s cubic-bezier(0.25, 1, 0.5, 1) both;
}

/* ── Upload icon bobbing ────────────────────────────────── */
#drop-area .upload-icon {
  animation: uploadBob 3s 1.2s ease-in-out infinite;
}
#drop-area.drag-over .upload-icon,
#drop-area:hover .upload-icon {
  animation: none;
  transform: scale(1.06);
  transition: transform 0.25s ease-out;
}

/* ── Upload icon color on hover ─────────────────────────── */
#drop-area:hover .upload-icon, #drop-area.drag-over .upload-icon { color: var(--accent); }
#drop-area .upload-icon { transition: color 0.25s, transform 0.25s; color: var(--tertiary); }

/* ── Card animations & hover ────────────────────────────── */
.icon-card.card-anim { animation: cardIn 0.35s cubic-bezier(0.22,1,0.36,1) both; }

/* ── Process panel entrance ─────────────────────────────── */
#process-panel.visible { animation: scaleIn 0.3s cubic-bezier(0.22,1,0.36,1) both; }

/* ── Keyline btn hover lift ─────────────────────────────── */
.keyline-btn:hover:not(.active) { transform: translateY(-1px); box-shadow: var(--shadow-sm); }

/* ── Save button hover ──────────────────────────────────── */
#save-btn {
  position: relative;
  overflow: hidden;
}

/* ── Browse link ────────────────────────────────────────── */
#browse-link {
  position: relative;
  text-decoration: none;
}
#browse-link::after {
  content: '';
  position: absolute;
  bottom: -1px; left: 0; right: 0;
  height: 1px;
  background: var(--accent);
  transform: scaleX(0);
  transform-origin: left;
  transition: transform 0.2s ease-out;
}
#browse-link:hover::after { transform: scaleX(1); }

/* ── Empty state ─────────────────────────────────────────── */
#empty-state {
  padding: 72px 24px;
}
.empty-glyph {
  width: 72px; height: 72px;
  margin: 0 auto 20px;
  opacity: 0.12;
}
#empty-state p { font-size: 13px; color: var(--secondary); }
#empty-state .empty-hint {
  font-size: 11px; color: var(--tertiary);
  margin-top: 5px; letter-spacing: 0.2px;
}

/* ── Spec table refinement ──────────────────────────────── */
.spec-table-wrap h3 {
  font-family: var(--font);
  font-size: 10px; letter-spacing: 1px;
  text-transform: uppercase; font-weight: 600;
}

/* ── Upload label refinement ────────────────────────────── */
#drop-area .upload-label { font-size: 15px; font-weight: 500; color: var(--primary); }
#drop-area .upload-hint  { font-size: 12px; color: var(--tertiary); margin-top: 4px; }

/* ── Queue bar dot animation ────────────────────────────── */
.q-dot.active { animation: pulseDot 1.2s infinite; background: var(--accent); }

/* Overlay toggle */
.norm-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
.norm-header h3 { margin-bottom: 0; }
#overlay-toggle {
  width: 24px; height: 24px; border-radius: 5px;
  border: 1px solid var(--border); background: white;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  color: var(--tertiary); transition: all 0.15s; flex-shrink: 0;
}
#overlay-toggle.active { border-color: var(--accent); color: var(--accent); }
#overlay-toggle:hover { border-color: var(--accent); color: var(--accent); }

/* Card checkbox */
.card-checkbox {
  position: absolute; top: 6px; left: 6px;
  width: 20px; height: 20px; border-radius: 5px;
  border: 1px solid var(--border); background: white;
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  opacity: 0; transition: opacity 0.15s, border-color 0.15s, background 0.15s;
  color: white; z-index: 2;
}
.icon-card:hover .card-checkbox,
.icon-card.selected .card-checkbox { opacity: 1; }
.card-checkbox.checked { background: var(--accent); border-color: var(--accent); opacity: 1; }
.icon-card.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(99,91,255,0.1); }

/* Selection bar */
#selection-bar { display: none; align-items: center; gap: 10px; padding: 14px 0 0; border-top: 1px solid var(--border); margin-top: 16px; }
#selection-bar.visible { display: flex; }
#sel-count { font-size: 12px; font-weight: 600; color: var(--primary); flex: 1; }
#sel-download-btn {
  padding: 8px 16px; background: var(--accent); color: white; border: none;
  border-radius: var(--radius-sm); font-family: var(--font);
  font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s;
}
#sel-download-btn:hover { background: var(--accent-hover); box-shadow: 0 2px 8px rgba(99,91,255,0.25); }
#sel-clear-btn {
  padding: 8px 14px; background: transparent; color: var(--secondary);
  border: 1px solid var(--border); border-radius: var(--radius-sm);
  font-family: var(--font); font-size: 12px; cursor: pointer; transition: all 0.15s;
}
#sel-clear-btn:hover { border-color: var(--border-mid); color: var(--primary); }
</style>
</head>
<body>

<!-- Hidden sandbox for getBBox() — must be in visible DOM -->
<div id="svg-sandbox" aria-hidden="true"></div>

<div id="app">
  <header>
    <div>
      <span class="header-line"></span>
      <h1>Icon Safe Area Normalizer <span class="v-badge">v3.1</span></h1>
      <p>Upload SVGs · normalize strokes to 1dp · fit to keyline · save to library</p>
    </div>
    <div style="display:flex;gap:8px;flex-shrink:0">
      <a href="icon-normalizer-figma-plugin.zip" download class="plugin-dl-btn">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none"><path d="M5 3H3v18h18v-2H5V3zm2 12l4-5.47L14.53 14 18 9.48l1.4 1.04L18 12.48l-3.47-4.04L11 13.53 7.97 9.52 7 15z" fill="currentColor"/></svg>
        <span>Figma plugin</span>
        <svg width="11" height="11" viewBox="0 0 12 12" fill="none"><path d="M6 2v6m0 0L3.5 5.5M6 8l2.5-2.5M2 10h8" stroke="currentColor" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </a>
      <button id="spec-toggle-btn">
        <span>Spec reference</span>
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2 4l4 4 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
    </div>
  </header>

  <!-- Collapsible spec panel -->
  <div id="spec-panel">
    <div class="spec-inner">
      <div class="spec-table-wrap">
        <h3>Canvas &amp; Safe Area</h3>
        <table class="spec-table">
          <thead>
            <tr><th>Size</th><th>Canvas</th><th>Safe Zone</th><th>Padding</th><th>Stroke</th></tr>
          </thead>
          <tbody>
            <tr><td>16dp</td><td>16×16</td><td>14×14</td><td>1dp</td><td>1dp</td></tr>
            <tr><td>24dp</td><td>24×24</td><td>20×20</td><td>2dp</td><td>1dp</td></tr>
            <tr><td>32dp</td><td>32×32</td><td>28×28</td><td>2dp</td><td>1dp</td></tr>
          </tbody>
        </table>
      </div>
      <div class="spec-table-wrap">
        <h3>Keyline Shapes (W × H)</h3>
        <table class="spec-table">
          <thead>
            <tr><th>Size</th><th>Circle</th><th>Square</th><th>Vertical</th><th>Horizontal</th></tr>
          </thead>
          <tbody>
            <tr><td>16dp</td><td>14dp ⌀</td><td>12×12</td><td>10×14</td><td>14×10</td></tr>
            <tr><td>24dp</td><td>20dp ⌀</td><td>18×18</td><td>16×20</td><td>20×16</td></tr>
            <tr><td>32dp</td><td>28dp ⌀</td><td>26×26</td><td>24×28</td><td>28×24</td></tr>
          </tbody>
        </table>
        <p style="font-size:11px;color:var(--secondary);margin-top:8px">Circle: circular icons · Square: geometric/square · Vertical: portrait (person, phone, door) · Horizontal: landscape (card, monitor)</p>
      </div>
    </div>
  </div>

  <!-- Upload zone -->
  <div id="upload-zone">
    <input type="file" id="file-input" accept=".svg" multiple style="display:none">
    <div id="drop-area">
      <div class="upload-icon">
        <svg width="40" height="40" viewBox="0 0 40 40" fill="none">
          <rect x="6" y="12" width="28" height="22" rx="3" stroke="currentColor" stroke-width="1.5"/>
          <path d="M14 20l6-6 6 6M20 14v14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <p class="upload-label">Drop SVG files here or <span id="browse-link">browse</span></p>
      <p class="upload-hint">Supports multiple files at once</p>
    </div>
  </div>

  <!-- Queue indicator -->
  <div id="queue-bar">
    <div class="queue-left">
      <span id="queue-text">Processing 1 of 1</span>
      <div id="queue-dots"></div>
    </div>
    <button id="skip-btn">Skip this icon</button>
  </div>

  <!-- Processing panel -->
  <div id="process-panel">
    <div class="panel-header">
      <h2 id="panel-filename">Icon name</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <div id="proc-error" class="proc-error">Could not parse SVG</div>
      </div>
    </div>

    <div class="panel-inner">
      <!-- Original preview -->
      <div class="preview-col">
        <h3>Original</h3>
        <div class="preview-box" id="original-preview"></div>
        <p id="original-info" style="font-size:11px;color:var(--secondary);margin-top:8px;text-align:center"></p>
      </div>

      <!-- Controls -->
      <div class="controls-col">
        <div class="control-group">
          <label>Icon name</label>
          <input type="text" id="icon-name" placeholder="e.g. arrow-right">
        </div>

        <div class="control-group">
          <label>Keyline shape</label>
          <div id="keyline-buttons">
            <button class="keyline-btn" data-keyline="circle">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <circle cx="17" cy="17" r="12" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Circle</span>
            </button>
            <button class="keyline-btn" data-keyline="square">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="5" y="5" width="24" height="24" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Square</span>
            </button>
            <button class="keyline-btn" data-keyline="vertical">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="8" y="3" width="18" height="28" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Vertical</span>
            </button>
            <button class="keyline-btn" data-keyline="horizontal">
              <span class="auto-badge">AUTO</span>
              <span class="kl-shape">
                <svg width="34" height="34" viewBox="0 0 34 34" fill="none">
                  <rect x="3" y="8" width="28" height="18" rx="2" stroke="currentColor" stroke-width="1.5"/>
                </svg>
              </span>
              <span class="kl-label">Horizontal</span>
            </button>
          </div>
        </div>

        <div class="control-group">
          <label>Canvas size</label>
          <div id="size-buttons">
            <button class="size-btn" data-size="16">16dp</button>
            <button class="size-btn active" data-size="24">24dp</button>
            <button class="size-btn" data-size="32">32dp</button>
          </div>
        </div>

        <button id="save-btn">Save to Library</button>
      </div>

      <!-- Normalized preview -->
      <div class="preview-col">
        <div class="norm-header">
          <h3>Normalized <span id="norm-info" style="font-weight:400;text-transform:none;letter-spacing:0"></span></h3>
          <button id="overlay-toggle" class="active" title="Toggle keyline overlay">
            <svg width="13" height="10" viewBox="0 0 13 10" fill="none">
              <ellipse cx="6.5" cy="5" rx="5.5" ry="4" stroke="currentColor" stroke-width="1.2"/>
              <circle cx="6.5" cy="5" r="1.8" fill="currentColor"/>
            </svg>
          </button>
        </div>
        <div id="norm-preview-wrap">
          <div id="norm-icon-layer"></div>
          <svg id="norm-overlay-layer" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet"></svg>
        </div>
        <div id="size-strip"></div>
      </div>
    </div>
  </div>

  <!-- Library -->
  <div id="library-section">
    <div id="library-header">
      <h2>Icon Library <span id="library-count">(0 icons)</span></h2>
      <button id="export-zip-btn" disabled>Export all as ZIP</button>
    </div>
    <div id="filter-bar">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="circle">Circle</button>
      <button class="filter-btn" data-filter="square">Square</button>
      <button class="filter-btn" data-filter="vertical">Vertical</button>
      <button class="filter-btn" data-filter="horizontal">Horizontal</button>
    </div>
    <div id="library-grid"></div>
    <div id="selection-bar">
      <span id="sel-count">0 selected</span>
      <button id="sel-download-btn">↓ Download (all 3 sizes)</button>
      <button id="sel-clear-btn">Clear</button>
    </div>
    <div id="empty-state" class="visible">
      <div class="empty-glyph">
        <svg viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="36" cy="36" r="28" stroke="currentColor" stroke-width="1" stroke-dasharray="3 3"/>
          <rect x="20" y="20" width="32" height="32" rx="2" stroke="currentColor" stroke-width="1.5"/>
          <line x1="36" y1="8" x2="36" y2="64" stroke="currentColor" stroke-width="1"/>
          <line x1="8" y1="36" x2="64" y2="36" stroke="currentColor" stroke-width="1"/>
          <circle cx="36" cy="36" r="3" fill="currentColor" opacity="0.4"/>
        </svg>
      </div>
      <p>No icons yet</p>
      <p class="empty-hint">Drop SVG files above to get started</p>
    </div>
  </div>
</div>

<div id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════════
// SPEC DATA
// ═══════════════════════════════════════════════════════════
const SPEC = {
  // keylines[size][type] = { w: width, h: height } in dp
  // For circle: w = h = diameter
  keylines: {
    16: {
      circle:     { w: 14, h: 14 },
      square:     { w: 12, h: 12 },
      vertical:   { w: 10, h: 14 },  // 10dp wide × 14dp tall (portrait)
      horizontal: { w: 14, h: 10 },  // 14dp wide × 10dp tall (landscape)
    },
    24: {
      circle:     { w: 20, h: 20 },
      square:     { w: 18, h: 18 },
      vertical:   { w: 16, h: 20 },  // 16dp wide × 20dp tall
      horizontal: { w: 20, h: 16 },  // 20dp wide × 16dp tall
    },
    32: {
      circle:     { w: 28, h: 28 },
      square:     { w: 26, h: 26 },
      vertical:   { w: 24, h: 28 },  // 24dp wide × 28dp tall
      horizontal: { w: 28, h: 24 },  // 28dp wide × 24dp tall
    },
  },
  padding: { 16: 1, 24: 2, 32: 2 },
  keylineColors: {
    circle: '#007aff',
    square: '#187A6C',
    vertical: '#B8912A',
    horizontal: '#7B5EA7',
  },
};

// ═══════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════
const state = {
  queue: [],        // Array of File objects
  queueIndex: 0,
  currentRawSvg: null,
  currentKeyline: 'square',
  currentSize: 24,
  currentNormalizedSvg: null,
  library: [],
  filter: 'all',
  overlayVisible: true,
  selectedIds: new Set(),
};

// ═══════════════════════════════════════════════════════════
// STORAGE
// ═══════════════════════════════════════════════════════════
const STORAGE_KEY = 'iconNormalizerLibrary_v1';

function loadLibrary() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    state.library = raw ? JSON.parse(raw) : [];
  } catch (e) {
    state.library = [];
  }
}

function saveLibraryToStorage() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state.library));
  } catch (e) {
    if (e.name === 'QuotaExceededError') {
      showToast('Storage full — some older icons may need to be removed', 'error');
    }
  }
}

function addToLibrary(icon) {
  state.library.unshift(icon);
  saveLibraryToStorage();
}

function deleteFromLibrary(id) {
  state.library = state.library.filter(ic => ic.id !== id);
  saveLibraryToStorage();
  renderLibrary();
  showToast('Icon removed');
}

// ═══════════════════════════════════════════════════════════
// TRANSFORM MATH + PATH FLATTENING
// ═══════════════════════════════════════════════════════════

// Affine matrix: [a, b, c, d, e, f]  →  x' = a·x + c·y + e,  y' = b·x + d·y + f
function matMul(p, q) {
  return [
    p[0]*q[0]+p[2]*q[1], p[1]*q[0]+p[3]*q[1],
    p[0]*q[2]+p[2]*q[3], p[1]*q[2]+p[3]*q[3],
    p[0]*q[4]+p[2]*q[5]+p[4], p[1]*q[4]+p[3]*q[5]+p[5],
  ];
}
function matApply(m, x, y) { return [m[0]*x+m[2]*y+m[4], m[1]*x+m[3]*y+m[5]]; }
function matScale(m) { return Math.sqrt(m[0]*m[0]+m[1]*m[1]); } // uniform scale magnitude

function parseTransformStr(s) {
  if (!s) return [1,0,0,1,0,0];
  let m = [1,0,0,1,0,0];
  const re = /(\w+)\s*\(([^)]*)\)/g;
  let match;
  while ((match = re.exec(s)) !== null) {
    const fn = match[1];
    const a = match[2].trim().split(/[\s,]+/).map(Number);
    let t = [1,0,0,1,0,0];
    if      (fn==='translate') t = [1,0,0,1,a[0]||0,a[1]||0];
    else if (fn==='scale')     { const sx=a[0]||1,sy=a.length>1?a[1]:sx; t=[sx,0,0,sy,0,0]; }
    else if (fn==='matrix')    t = a.slice(0,6);
    else if (fn==='rotate') {
      const ang=(a[0]||0)*Math.PI/180, cos=Math.cos(ang), sin=Math.sin(ang);
      const cx=a[1]||0, cy=a[2]||0;
      t = [cos, sin, -sin, cos, cx-cos*cx+sin*cy, cy-sin*cx-cos*cy];
    }
    m = matMul(m, t);
  }
  return m;
}

// Transform SVG path d attribute by matrix m
function transformPathD(d, m) {
  if (!d) return d;
  const tokens = [];
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match;
  while ((match = re.exec(d)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const out = [];
  let i = 0, cx = 0, cy = 0, sx = 0, sy = 0, prevCmd = 'M';
  const n = () => tokens[i++];
  const f = v => parseFloat(v.toFixed(4));

  while (i < tokens.length) {
    let cmd = typeof tokens[i] === 'string' ? (prevCmd = tokens[i++]) : prevCmd;
    const C = cmd.toUpperCase(), rel = cmd !== C;

    if (C === 'Z') { out.push('Z'); cx=sx; cy=sy; continue; }

    if (C === 'M') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`M${f(nx)},${f(ny)}`);
      cx=x;cy=y;sx=x;sy=y; prevCmd=rel?'l':'L';
    } else if (C === 'L') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`L${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'H') {
      let x=n(); if (rel) x+=cx;
      const [nx,ny]=matApply(m,x,cy); out.push(`L${f(nx)},${f(ny)}`); cx=x;
    } else if (C === 'V') {
      let y=n(); if (rel) y+=cy;
      const [nx,ny]=matApply(m,cx,y); out.push(`L${f(nx)},${f(ny)}`); cy=y;
    } else if (C === 'C') {
      let x1=n(),y1=n(),x2=n(),y2=n(),x=n(),y=n();
      if (rel){x1+=cx;y1+=cy;x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`C${f(a1)},${f(b1)},${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'S') {
      let x2=n(),y2=n(),x=n(),y=n(); if (rel){x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`S${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'Q') {
      let x1=n(),y1=n(),x=n(),y=n(); if (rel){x1+=cx;y1+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[nx,ny]=matApply(m,x,y);
      out.push(`Q${f(a1)},${f(b1)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'T') {
      let x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`T${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'A') {
      let rx=n(),ry=n(),rot=n(),la=n(),sw=n(),x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const sc=matScale(m), [nx,ny]=matApply(m,x,y);
      out.push(`A${f(rx*sc)},${f(ry*sc)},${rot},${la},${sw},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else { while (i<tokens.length && typeof tokens[i]==='number') i++; }
  }
  return out.join(' ');
}

// Apply matrix m to element's own coordinates (shape elements only)
const FLATTEN_TAGS = new Set(['path','line','circle','ellipse','rect','polyline','polygon']);
function flattenElement(el, m) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v.toFixed(4));
  const sc = matScale(m);
  if (tag === 'path') {
    const d = el.getAttribute('d'); if (d) el.setAttribute('d', transformPathD(d, m));
  } else if (tag === 'line') {
    const [nx1,ny1]=matApply(m,+(el.getAttribute('x1')||0),+(el.getAttribute('y1')||0));
    const [nx2,ny2]=matApply(m,+(el.getAttribute('x2')||0),+(el.getAttribute('y2')||0));
    el.setAttribute('x1',f(nx1));el.setAttribute('y1',f(ny1));
    el.setAttribute('x2',f(nx2));el.setAttribute('y2',f(ny2));
  } else if (tag === 'circle') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('r',f(+(el.getAttribute('r')||0)*sc));
  } else if (tag === 'ellipse') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('rx',f(+(el.getAttribute('rx')||0)*sc));
    el.setAttribute('ry',f(+(el.getAttribute('ry')||0)*sc));
  } else if (tag === 'rect') {
    const [nx,ny]=matApply(m,+(el.getAttribute('x')||0),+(el.getAttribute('y')||0));
    el.setAttribute('x',f(nx));el.setAttribute('y',f(ny));
    el.setAttribute('width',f(+(el.getAttribute('width')||0)*sc));
    el.setAttribute('height',f(+(el.getAttribute('height')||0)*sc));
    const rx=el.getAttribute('rx'),ry=el.getAttribute('ry');
    if (rx) el.setAttribute('rx',f(+rx*sc));
    if (ry) el.setAttribute('ry',f(+ry*sc));
  } else if (tag === 'polyline' || tag === 'polygon') {
    const pts=(el.getAttribute('points')||'').trim().split(/[\s,]+/).map(Number);
    const out=[];
    for (let k=0;k<pts.length-1;k+=2){const[nx,ny]=matApply(m,pts[k],pts[k+1]);out.push(`${f(nx)},${f(ny)}`);}
    el.setAttribute('points',out.join(' '));
  }
  el.removeAttribute('transform');
}

// Recursively walk SVG tree, accumulate group transforms, flatten each shape into parentMat space
function walkFlatten(node, parentMat) {
  if (node.nodeType !== 1) return;
  const tag = node.tagName.toLowerCase();
  if (FLATTEN_TAGS.has(tag)) {
    const elMat = parseTransformStr(node.getAttribute('transform'));
    flattenElement(node, matMul(parentMat, elMat));
  } else {
    const groupMat = (tag === 'g' || tag === 'svg')
      ? matMul(parentMat, parseTransformStr(node.getAttribute('transform')))
      : parentMat;
    if (tag === 'g') node.removeAttribute('transform');
    Array.from(node.childNodes).forEach(child => walkFlatten(child, groupMat));
  }
}

// ═══════════════════════════════════════════════════════════
// SVG PARSING + NORMALIZATION
// ═══════════════════════════════════════════════════════════

function parseSVGString(svgString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgString, 'image/svg+xml');
  const root = doc.documentElement;
  if (root.querySelector('parsererror')) {
    throw new Error('Invalid SVG — parse error');
  }
  if (root.tagName.toLowerCase() !== 'svg') {
    throw new Error('File does not contain an SVG root element');
  }
  return { doc, root };
}

function ensureViewBox(svgEl) {
  // Make sure we have a viewBox
  const vb = svgEl.viewBox && svgEl.viewBox.baseVal;
  if (vb && vb.width > 0 && vb.height > 0) {
    return { x: vb.x, y: vb.y, w: vb.width, h: vb.height };
  }
  // Fall back to width/height attrs
  const w = parseFloat(svgEl.getAttribute('width')) || 24;
  const h = parseFloat(svgEl.getAttribute('height')) || 24;
  svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
  return { x: 0, y: 0, w, h };
}

function getContentBBox(svgString) {
  // Render in sandbox, get the bounding box of all visible content
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  if (!liveSvg) return null;

  // Force a display size so layout is computed
  liveSvg.removeAttribute('width');
  liveSvg.removeAttribute('height');
  liveSvg.style.width = '200px';
  liveSvg.style.height = '200px';

  // Ensure viewBox exists
  const vbInfo = ensureViewBox(liveSvg);

  // Create a temporary g containing all drawable children
  const tempG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  const drawable = Array.from(liveSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  drawable.forEach(child => tempG.appendChild(child.cloneNode(true)));
  liveSvg.appendChild(tempG);

  let bbox = null;
  try {
    bbox = tempG.getBBox();
  } catch (e) { /* getBBox not available */ }

  liveSvg.removeChild(tempG);
  sandbox.innerHTML = '';

  if (!bbox || bbox.width === 0 || bbox.height === 0) {
    // Fallback: use viewBox dimensions
    return { x: vbInfo.x, y: vbInfo.y, width: vbInfo.w, height: vbInfo.h, vbInfo };
  }

  return { x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height, vbInfo };
}

// Geometric circle test — render a closed subpath in a temp SVG,
// sample 12 points with getPointAtLength, check if all are
// equidistant from center (i.e. the shape is circular).
function isSubpathCircular(subD, sandbox) {
  const ns = 'http://www.w3.org/2000/svg';
  const tempSvg = document.createElementNS(ns, 'svg');
  tempSvg.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden';
  const tempPath = document.createElementNS(ns, 'path');
  tempPath.setAttribute('d', subD);
  tempSvg.appendChild(tempPath);
  sandbox.appendChild(tempSvg);

  let circular = false;
  try {
    const bb = tempPath.getBBox();
    if (bb.width > 0 && bb.height > 0) {
      const ratio = bb.width / bb.height;
      if (Math.abs(ratio - 1) < 0.15) {
        const cx = bb.x + bb.width / 2;
        const cy = bb.y + bb.height / 2;
        const expectedR = (bb.width + bb.height) / 4;
        const totalLen = tempPath.getTotalLength();
        if (totalLen > 0 && expectedR > 0) {
          circular = true;
          for (let i = 0; i < 12; i++) {
            const pt = tempPath.getPointAtLength((i / 12) * totalLen);
            const dist = Math.sqrt((pt.x - cx) ** 2 + (pt.y - cy) ** 2);
            if (Math.abs(dist - expectedR) / expectedR > 0.12) {
              circular = false;
              break;
            }
          }
        }
      }
    }
  } catch (_) {}

  tempSvg.remove();
  return circular;
}

function detectKeyline(svgString, bbox) {
  // Check for circle/ellipse as dominant element — supports native elements,
  // arc-based paths, AND bezier-curve paths (common Figma/Illustrator export)
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  let hasCircleShape = false;

  // Collect path d-attributes while the SVG is in the DOM
  const pathDatas = [];

  if (liveSvg) {
    // 1. Direct <circle> elements
    const circles = liveSvg.querySelectorAll('circle');
    const otherShapes = liveSvg.querySelectorAll('path, rect, line, polyline, polygon');
    if (circles.length > 0 && otherShapes.length <= 1) hasCircleShape = true;

    // 2. <ellipse> elements with nearly equal rx/ry
    if (!hasCircleShape) {
      for (const el of liveSvg.querySelectorAll('ellipse')) {
        const rx = parseFloat(el.getAttribute('rx') || 0);
        const ry = parseFloat(el.getAttribute('ry') || 0);
        if (rx > 0 && ry > 0 && Math.abs(rx / ry - 1) < 0.15) {
          hasCircleShape = true;
          break;
        }
      }
    }

    // Collect path data for geometric check (step 3)
    if (!hasCircleShape) {
      for (const p of liveSvg.querySelectorAll('path')) {
        const d = p.getAttribute('d') || '';
        if (d) pathDatas.push(d);
      }
    }
  }
  sandbox.innerHTML = '';

  // 3. Geometric circle detection — split compound paths into subpaths,
  //    render each in a temp SVG, sample points to check circularity.
  //    Works for arcs, cubic beziers, or any curve that forms a circle.
  if (!hasCircleShape && pathDatas.length > 0) {
    for (const d of pathDatas) {
      const subpaths = d.split(/(?=[Mm])/).filter(s => s.trim());
      for (const sub of subpaths) {
        if (!/[Zz]/.test(sub)) continue; // only closed subpaths
        if (isSubpathCircular(sub, sandbox)) {
          hasCircleShape = true;
          break;
        }
      }
      if (hasCircleShape) break;
    }
  }

  if (!bbox || bbox.width === 0 || bbox.height === 0) return 'square';

  const ratio = bbox.width / bbox.height;
  const isSquarish = Math.abs(ratio - 1) < 0.15;

  if (isSquarish && hasCircleShape) return 'circle';
  if (isSquarish) return 'square';
  if (ratio < 0.85) return 'vertical';   // taller than wide
  if (ratio > 1.15) return 'horizontal'; // wider than tall
  return 'square';
}

// Convert any SVG shape element to a path `d` string.
// Assumes coordinates are already in their final (dp) space.
function shapeToPathD(el) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v || 0);

  if (tag === 'path') return el.getAttribute('d') || '';

  if (tag === 'line') {
    const x1 = f(el.getAttribute('x1')), y1 = f(el.getAttribute('y1'));
    const x2 = f(el.getAttribute('x2')), y2 = f(el.getAttribute('y2'));
    return `M ${x1} ${y1} L ${x2} ${y2}`;
  }

  if (tag === 'rect') {
    const x = f(el.getAttribute('x')), y = f(el.getAttribute('y'));
    const w = f(el.getAttribute('width')), h = f(el.getAttribute('height'));
    const rx = Math.min(f(el.getAttribute('rx')), w / 2);
    const ry = Math.min(f(el.getAttribute('ry') || el.getAttribute('rx')), h / 2);
    if (rx === 0 && ry === 0) return `M ${x} ${y} H ${x + w} V ${y + h} H ${x} Z`;
    return `M ${x + rx} ${y} H ${x + w - rx} A ${rx} ${ry} 0 0 1 ${x + w} ${y + ry} V ${y + h - ry} A ${rx} ${ry} 0 0 1 ${x + w - rx} ${y + h} H ${x + rx} A ${rx} ${ry} 0 0 1 ${x} ${y + h - ry} V ${y + ry} A ${rx} ${ry} 0 0 1 ${x + rx} ${y} Z`;
  }

  if (tag === 'circle') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const r = f(el.getAttribute('r'));
    return `M ${cx - r} ${cy} A ${r} ${r} 0 1 0 ${cx + r} ${cy} A ${r} ${r} 0 1 0 ${cx - r} ${cy} Z`;
  }

  if (tag === 'ellipse') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const rx2 = f(el.getAttribute('rx')), ry2 = f(el.getAttribute('ry'));
    return `M ${cx - rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx + rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx - rx2} ${cy} Z`;
  }

  if (tag === 'polyline' || tag === 'polygon') {
    const pts = (el.getAttribute('points') || '').trim().split(/[\s,]+/);
    const pairs = [];
    for (let i = 0; i + 1 < pts.length; i += 2) pairs.push(`${pts[i]} ${pts[i + 1]}`);
    if (!pairs.length) return '';
    const d = `M ${pairs.join(' L ')}`;
    return tag === 'polygon' ? d + ' Z' : d;
  }
  return '';
}

// Returns true if the path `d` string represents a closed shape (ends with Z/z).
function isClosedPath(d) {
  return /[Zz]\s*$/.test((d || '').trim());
}

// Compute the inner boundary of a closed path by scaling all coordinates toward the
// path's bounding-box center, insetting by 1dp on each side. Uses transformPathD.
function makeInnerDFromPath(outerD) {
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match, cx = 0, cy = 0, cmd = 'M';
  const tokens = [];
  while ((match = re.exec(outerD)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const coords = [];
  let i = 0;
  while (i < tokens.length) {
    if (typeof tokens[i] === 'string') { cmd = tokens[i++]; continue; }
    const C = cmd.toUpperCase(), rel = cmd !== C;
    if (C === 'Z') continue;
    if (C === 'M' || C === 'L' || C === 'T') {
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'H') {
      let x = tokens[i++]; if (rel) x += cx; cx = x;
      coords.push([cx, cy]);
    } else if (C === 'V') {
      let y = tokens[i++]; if (rel) y += cy; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'C') {
      for (let j = 0; j < 3; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 2) { cx = x; cy = y; }
      }
    } else if (C === 'S' || C === 'Q') {
      for (let j = 0; j < 2; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 1) { cx = x; cy = y; }
      }
    } else if (C === 'A') {
      i += 5; // skip rx, ry, rot, la, sw
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else { i++; }
  }

  if (coords.length < 2) return '';
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  coords.forEach(([x, y]) => {
    if (x < minX) minX = x; if (x > maxX) maxX = x;
    if (y < minY) minY = y; if (y > maxY) maxY = y;
  });
  const w = maxX - minX, h = maxY - minY;
  if (w <= 2 || h <= 2) return ''; // inner shape would collapse

  const cxB = minX + w / 2, cyB = minY + h / 2;
  const sxF = (w - 2) / w, syF = (h - 2) / h; // inset by 1dp on each side
  // Scale toward bbox center: x' = cx + (x - cx) * sx = sx*x + cx*(1-sx)
  const mat = [sxF, 0, 0, syF, cxB * (1 - sxF), cyB * (1 - syF)];
  return transformPathD(outerD, mat);
}

// Convert a stroked path to a filled outline path using point sampling.
// Samples points along the path, computes perpendicular normals, offsets
// outward/inward by half the stroke-width. Returns a fill-only d-string.
//   - Closed paths → evenodd ring (outer + reversed inner contours)
//   - Open paths → single closed contour (outer → end cap → inner reversed → start cap)
function strokeToFillPath(pathD, strokeWidth, linecap, linejoin, miterlimit, sandbox, outerOnly) {
  if (!pathD || strokeWidth < 0.001) return '';

  const ns = 'http://www.w3.org/2000/svg';
  const tempSvg = document.createElementNS(ns, 'svg');
  tempSvg.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden';
  const tempPath = document.createElementNS(ns, 'path');
  tempPath.setAttribute('d', pathD);
  tempSvg.appendChild(tempPath);
  sandbox.appendChild(tempSvg);

  let result = '';
  try {
    const totalLen = tempPath.getTotalLength();
    if (totalLen < 0.001) { tempSvg.remove(); return ''; }

    const closed = /[Zz]\s*$/.test(pathD.trim());
    const halfW = strokeWidth / 2;
    const numSamples = Math.max(16, Math.round(totalLen * 4));
    const dt = Math.min(0.05, totalLen * 0.0005);
    const f = v => parseFloat(v.toFixed(4));

    const outerPts = [];
    const innerPts = [];

    for (let i = 0; i <= numSamples; i++) {
      const t = Math.min((i / numSamples) * totalLen, totalLen);
      const pt = tempPath.getPointAtLength(t);

      // Central-difference tangent
      const t0 = Math.max(0, t - dt);
      const t1 = Math.min(totalLen, t + dt);
      const p0 = tempPath.getPointAtLength(t0);
      const p1 = tempPath.getPointAtLength(t1);
      const tdx = p1.x - p0.x;
      const tdy = p1.y - p0.y;
      const tlen = Math.sqrt(tdx * tdx + tdy * tdy);

      let nx, ny;
      if (tlen < 1e-10) {
        if (outerPts.length > 0) {
          // Reuse previous normal direction for degenerate tangent
          const prevO = outerPts[outerPts.length - 1];
          const prevI = innerPts[innerPts.length - 1];
          nx = (prevO.x - prevI.x); ny = (prevO.y - prevI.y);
          const nl = Math.sqrt(nx * nx + ny * ny);
          if (nl > 1e-10) { nx /= nl; ny /= nl; }
          else { nx = 0; ny = -1; }
        } else { nx = 0; ny = -1; }
      } else {
        // Normal = perpendicular to tangent (left-hand rule)
        nx = -tdy / tlen;
        ny = tdx / tlen;
      }

      outerPts.push({ x: pt.x + nx * halfW, y: pt.y + ny * halfW });
      innerPts.push({ x: pt.x - nx * halfW, y: pt.y - ny * halfW });
    }

    // For open paths, extend endpoints along the tangent direction so adjacent
    // fill outlines overlap at junctions instead of leaving anti-aliasing gaps.
    if (!closed) {
      const EXT = halfW; // extend by half the stroke width at each end

      // Start extension (backward along path direction)
      const s0 = tempPath.getPointAtLength(0);
      const s1 = tempPath.getPointAtLength(Math.min(dt * 2, totalLen));
      let bx = s0.x - s1.x, by = s0.y - s1.y;
      const bl = Math.sqrt(bx * bx + by * by);
      if (bl > 1e-10) { bx /= bl; by /= bl; } else { bx = 0; by = 0; }
      outerPts.unshift({ x: outerPts[0].x + bx * EXT, y: outerPts[0].y + by * EXT });
      innerPts.unshift({ x: innerPts[0].x + bx * EXT, y: innerPts[0].y + by * EXT });

      // End extension (forward along path direction)
      const e0 = tempPath.getPointAtLength(totalLen);
      const e1 = tempPath.getPointAtLength(Math.max(0, totalLen - dt * 2));
      let fx = e0.x - e1.x, fy = e0.y - e1.y;
      const fl = Math.sqrt(fx * fx + fy * fy);
      if (fl > 1e-10) { fx /= fl; fy /= fl; } else { fx = 0; fy = 0; }
      outerPts.push({ x: outerPts[outerPts.length - 1].x + fx * EXT, y: outerPts[outerPts.length - 1].y + fy * EXT });
      innerPts.push({ x: innerPts[innerPts.length - 1].x + fx * EXT, y: innerPts[innerPts.length - 1].y + fy * EXT });
    }

    if (closed) {
      // Outer contour
      let d = `M${f(outerPts[0].x)},${f(outerPts[0].y)}`;
      for (let i = 1; i < outerPts.length; i++) {
        d += ` L${f(outerPts[i].x)},${f(outerPts[i].y)}`;
      }
      d += ' Z';
      if (!outerOnly) {
        // Full ring: add reversed inner contour (use with fill-rule="evenodd")
        const last = innerPts.length - 1;
        d += ` M${f(innerPts[last].x)},${f(innerPts[last].y)}`;
        for (let i = last - 1; i >= 0; i--) {
          d += ` L${f(innerPts[i].x)},${f(innerPts[i].y)}`;
        }
        d += ' Z';
      }
      result = d;
    } else {
      // Open path: outer → end cap → inner reversed → start cap → close
      let d = `M${f(outerPts[0].x)},${f(outerPts[0].y)}`;
      for (let i = 1; i < outerPts.length; i++) {
        d += ` L${f(outerPts[i].x)},${f(outerPts[i].y)}`;
      }

      // End cap
      const endO = outerPts[outerPts.length - 1];
      const endI = innerPts[innerPts.length - 1];
      if (linecap === 'round') {
        d += ` A${f(halfW)},${f(halfW)} 0 0 1 ${f(endI.x)},${f(endI.y)}`;
      } else if (linecap === 'square') {
        const lastPt = tempPath.getPointAtLength(totalLen);
        const prevPt = tempPath.getPointAtLength(Math.max(0, totalLen - dt));
        let tx = lastPt.x - prevPt.x, ty = lastPt.y - prevPt.y;
        const tl = Math.sqrt(tx * tx + ty * ty);
        if (tl > 1e-10) { tx /= tl; ty /= tl; } else { tx = 1; ty = 0; }
        d += ` L${f(endO.x + tx * halfW)},${f(endO.y + ty * halfW)}`;
        d += ` L${f(endI.x + tx * halfW)},${f(endI.y + ty * halfW)}`;
        d += ` L${f(endI.x)},${f(endI.y)}`;
      } else {
        // butt cap — straight line
        d += ` L${f(endI.x)},${f(endI.y)}`;
      }

      // Inner contour reversed
      for (let i = innerPts.length - 2; i >= 0; i--) {
        d += ` L${f(innerPts[i].x)},${f(innerPts[i].y)}`;
      }

      // Start cap
      const startO = outerPts[0];
      const startI = innerPts[0];
      if (linecap === 'round') {
        d += ` A${f(halfW)},${f(halfW)} 0 0 1 ${f(startO.x)},${f(startO.y)}`;
      } else if (linecap === 'square') {
        const firstPt = tempPath.getPointAtLength(0);
        const nextPt = tempPath.getPointAtLength(Math.min(dt, totalLen));
        let tx = firstPt.x - nextPt.x, ty = firstPt.y - nextPt.y;
        const tl = Math.sqrt(tx * tx + ty * ty);
        if (tl > 1e-10) { tx /= tl; ty /= tl; } else { tx = -1; ty = 0; }
        d += ` L${f(startI.x + tx * halfW)},${f(startI.y + ty * halfW)}`;
        d += ` L${f(startO.x + tx * halfW)},${f(startO.y + ty * halfW)}`;
      }
      d += ' Z';
      result = d;
    }
  } catch (_) { result = ''; }

  tempSvg.remove();
  return result;
}

// Merge all shapes in contentG into flat compound paths grouped by style signature.
// Removes all <g> wrappers → flat <path> elements only.
//
// ALL output paths are purely filled — no stroke attributes.
// Strokes are "baked" into fill geometry:
//   - Closed stroke-only shapes → evenodd fill (outer + inset inner boundary)
//   - Filled paths (scaled) → compensating stroke outline merged into fill
//   - Open stroked / filled+stroked → stroke outline converted to fill
function flattenToCompoundPaths(contentG, s) {
  const SHAPE_TAGS = new Set(['path', 'line', 'circle', 'ellipse', 'rect', 'polyline', 'polygon']);
  // Inside-stroke visual weight in dp. With viewBox/width/height set to the canvas size,
  // 1 SVG unit = 1dp, so SW=1 is always 1dp regardless of output size.
  const SW = 1;

  // Default stroke to 'none' — do NOT fall back to 'currentColor'.
  const cgStroke      = contentG.getAttribute('stroke')            || 'none';
  const cgFill        = contentG.getAttribute('fill')              || 'none';
  const cgStrokeWidth = contentG.getAttribute('stroke-width')      || '1';
  const cgLinecap     = contentG.getAttribute('stroke-linecap')    || '';
  const cgLinejoin    = contentG.getAttribute('stroke-linejoin')   || '';
  const cgMiterlimit  = contentG.getAttribute('stroke-miterlimit') || '';

  function styleVal(node, prop) {
    const sv = node.getAttribute('style') || '';
    const m = sv.match(new RegExp('(?:^|;)\\s*' + prop + '\\s*:\\s*([^;]+)'));
    return m ? m[1].trim() : '';
  }

  // Build the path `d` for the INNER boundary of a closed simple shape inset by SW.
  // Returns '' if the inner shape would collapse to zero or negative size.
  function makeInnerD(node, tag) {
    const f = v => parseFloat(v || '0');
    const tmp = node.ownerDocument.createElementNS('http://www.w3.org/2000/svg', tag);
    if (tag === 'rect') {
      const x = f(node.getAttribute('x')), y = f(node.getAttribute('y'));
      const w = f(node.getAttribute('width')), h = f(node.getAttribute('height'));
      const rxRaw = f(node.getAttribute('rx')), ryRaw = f(node.getAttribute('ry') || node.getAttribute('rx'));
      const iw = w - 2 * SW, ih = h - 2 * SW;
      if (iw <= 0 || ih <= 0) return '';
      tmp.setAttribute('x',      x + SW);
      tmp.setAttribute('y',      y + SW);
      tmp.setAttribute('width',  iw);
      tmp.setAttribute('height', ih);
      tmp.setAttribute('rx', Math.max(rxRaw - SW, 0));
      tmp.setAttribute('ry', Math.max(ryRaw - SW, 0));
    } else if (tag === 'circle') {
      const r = f(node.getAttribute('r'));
      if (r - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('r',  r - SW);
    } else if (tag === 'ellipse') {
      const rx = f(node.getAttribute('rx')), ry = f(node.getAttribute('ry'));
      if (rx - SW <= 0 || ry - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('rx', rx - SW);
      tmp.setAttribute('ry', ry - SW);
    }
    return shapeToPathD(tmp);
  }

  const items = [];
  function collect(node) {
    if (node.nodeType !== 1) return;
    const tag = node.tagName.toLowerCase();
    if (SHAPE_TAGS.has(tag)) {
      const stroke      = node.getAttribute('stroke')            || styleVal(node, 'stroke')            || cgStroke;
      const fill        = node.getAttribute('fill')              || styleVal(node, 'fill')              || cgFill;
      const strokeWidth = node.getAttribute('stroke-width')      || styleVal(node, 'stroke-width')      || cgStrokeWidth;
      const linecap     = node.getAttribute('stroke-linecap')    || styleVal(node, 'stroke-linecap')    || cgLinecap;
      const linejoin    = node.getAttribute('stroke-linejoin')   || styleVal(node, 'stroke-linejoin')   || cgLinejoin;
      const miterlimit  = node.getAttribute('stroke-miterlimit') || styleVal(node, 'stroke-miterlimit') || cgMiterlimit;

      const hasStroke = stroke && stroke !== 'none';
      const hasFill   = fill   && fill   !== 'none';

      // ── Inside-stroke-to-fill conversion ──
      // Closed shapes with stroke only (fill=none) are converted to filled evenodd
      // "frame" paths (outer + inner boundary inset by 1dp). This replicates a 1dp
      // inside stroke with no outward bleed, giving identical visual weight at all sizes.
      const isClosedSimple = tag === 'rect' || tag === 'circle' || tag === 'ellipse';
      const isClosedPathEl = tag === 'path' && isClosedPath(shapeToPathD(node));
      if (hasStroke && !hasFill && (isClosedSimple || isClosedPathEl)) {
        const outerD = shapeToPathD(node);
        if (!outerD) return;
        const innerD = isClosedSimple ? makeInnerD(node, tag) : makeInnerDFromPath(outerD);
        const combinedD = innerD ? outerD + ' ' + innerD : outerD;
        items.push({
          d:           combinedD,
          fill:        stroke,                      // stroke colour → fill colour
          stroke:      'none',
          fillRule:    innerD ? 'evenodd' : 'nonzero',
          strokeWidth: '0',
          linecap, linejoin, miterlimit,
        });
        return;
      }

      // ── Filled paths: expand with outer contour of compensating stroke ──
      // When geometry is scaled by s < 1, filled line widths become s dp.
      // We emit the original fill path + the OUTER contour of a (1−s) dp stroke
      // as separate items. The outer contour overlaps the fill edge, so no gap
      // appears (unlike a merged compound path which has anti-aliasing seams).
      if (hasFill && !hasStroke) {
        const d = shapeToPathD(node);
        if (!d) return;
        const compSW = Math.max(0, 1 - s);
        const sandbox = document.getElementById('svg-sandbox');
        // Always emit the original fill path
        items.push({
          d, fill,
          stroke: 'none', strokeWidth: '0',
          fillRule: node.getAttribute('fill-rule') || 'nonzero',
          linecap: '', linejoin: '', miterlimit: '',
        });
        // Add outer contour of compensating stroke (overlaps fill edge → no gap)
        if (compSW > 0.001) {
          const outerD = strokeToFillPath(d, compSW, 'butt', 'miter', '10', sandbox, true);
          if (outerD) {
            items.push({
              d: outerD, fill,
              stroke: 'none', strokeWidth: '0',
              fillRule: 'nonzero',
              linecap: '', linejoin: '', miterlimit: '',
            });
          }
        }
        return;
      }

      // ── All other stroked paths: convert stroke to fill outline ──
      const d = shapeToPathD(node);
      if (!d) return;
      const sandbox = document.getElementById('svg-sandbox');

      if (hasStroke && !hasFill) {
        // Stroke-only open path (lines, polylines, open paths)
        const strokeOutlineD = strokeToFillPath(d, SW, linecap, linejoin, miterlimit, sandbox);
        if (!strokeOutlineD) return;
        const isClosed = /[Zz]\s*$/.test(d.trim());
        items.push({
          d:        strokeOutlineD,
          fill:     stroke,           // stroke colour becomes fill
          stroke:   'none',
          strokeWidth: '0',
          fillRule: isClosed ? 'evenodd' : 'nonzero',
          linecap: '', linejoin: '', miterlimit: '',
        });
      } else if (hasStroke && hasFill) {
        // Filled + stroked
        const strokeOutlineD = strokeToFillPath(d, SW, linecap, linejoin, miterlimit, sandbox);
        if (stroke === fill) {
          // Same colour: merge fill + stroke outline as compound, nonzero
          items.push({
            d: strokeOutlineD ? d + ' ' + strokeOutlineD : d,
            fill,
            stroke: 'none', strokeWidth: '0',
            fillRule: node.getAttribute('fill-rule') || 'nonzero',
            linecap: '', linejoin: '', miterlimit: '',
          });
        } else {
          // Different colours: two separate items
          items.push({
            d, fill,
            stroke: 'none', strokeWidth: '0',
            fillRule: node.getAttribute('fill-rule') || 'nonzero',
            linecap: '', linejoin: '', miterlimit: '',
          });
          if (strokeOutlineD) {
            const isClosed = /[Zz]\s*$/.test(d.trim());
            items.push({
              d: strokeOutlineD,
              fill: stroke,
              stroke: 'none', strokeWidth: '0',
              fillRule: isClosed ? 'evenodd' : 'nonzero',
              linecap: '', linejoin: '', miterlimit: '',
            });
          }
        }
      } else {
        // No stroke — fill-only pass-through
        items.push({
          d, fill: hasFill ? fill : 'none',
          stroke: 'none', strokeWidth: '0',
          fillRule: node.getAttribute('fill-rule') || 'nonzero',
          linecap: '', linejoin: '', miterlimit: '',
        });
      }
    } else {
      Array.from(node.childNodes).forEach(collect);
    }
  }
  Array.from(contentG.childNodes).forEach(collect);
  if (!items.length) return;

  // Group by full style signature. Paths with the same signature share a single <path>.
  // EXCEPT evenodd paths — merging evenodd sub-paths causes overlapping regions to cancel
  // out (winding count 2 → unfilled). Each evenodd path stays as its own <path> element.
  const groups = new Map();
  let eoCounter = 0;
  items.forEach(it => {
    const base = [it.stroke, it.fill, it.strokeWidth, it.linecap, it.linejoin, it.miterlimit, it.fillRule].join('|');
    const key = it.fillRule === 'evenodd' ? base + '|eo' + (eoCounter++) : base;
    if (!groups.has(key)) groups.set(key, { it, dParts: [] });
    groups.get(key).dParts.push(it.d);
  });

  while (contentG.firstChild) contentG.removeChild(contentG.firstChild);
  ['stroke', 'fill', 'stroke-width', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit'].forEach(a =>
    contentG.removeAttribute(a));

  const ns = 'http://www.w3.org/2000/svg';
  groups.forEach(({ it, dParts }) => {
    const p = contentG.ownerDocument.createElementNS(ns, 'path');
    p.setAttribute('d', dParts.join(' '));
    if (it.fillRule === 'evenodd') p.setAttribute('fill-rule', 'evenodd');
    p.setAttribute('fill', it.fill || 'none');
    // No stroke attributes — all strokes baked into fills
    contentG.appendChild(p);
  });
}

function normalizeSVG(svgString, keyline, size) {
  const { doc, root: svgEl } = parseSVGString(svgString);
  const serializer = new XMLSerializer();

  // Ensure viewBox
  ensureViewBox(svgEl);

  // Get content bounding box via sandbox render
  const bboxData = getContentBBox(svgString);
  if (!bboxData) throw new Error('Could not compute bounding box');

  const { x: bx, y: by, width: bw, height: bh, vbInfo } = bboxData;

  // Keyline dimensions for target size
  const kl = SPEC.keylines[size][keyline];

  // Scale factor: fit content bounding box into keyline bounds.
  const sx = kl.w / bw;
  const sy = kl.h / bh;
  const s = Math.min(sx, sy);

  // Translation to centre content in the canvas
  const tx = size / 2 - (bx + bw / 2) * s;
  const ty = size / 2 - (by + bh / 2) * s;

  // ── Build output SVG ──
  // Re-parse the original SVG cleanly
  const { doc: outDoc, root: outSvg } = parseSVGString(svgString);

  // viewBox = "0 0 size size" — 1 SVG unit = 1dp exactly.
  // All path coordinates will be flattened into this dp space,
  // so stroke-width="1" = 1dp directly. No renderer ambiguity.
  outSvg.setAttribute('viewBox', `0 0 ${size} ${size}`);
  outSvg.setAttribute('width', String(size));
  outSvg.setAttribute('height', String(size));
  outSvg.setAttribute('fill', 'none');
  outSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  outSvg.removeAttribute('class');
  outSvg.removeAttribute('style');
  outSvg.removeAttribute('preserveAspectRatio');

  // Collect non-defs children to move into content group
  const childrenToWrap = Array.from(outSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  // Content group — no transform; coordinates are flattened into dp space below.
  const contentG = outDoc.createElementNS('http://www.w3.org/2000/svg', 'g');
  contentG.setAttribute('id', 'icon-content');

  childrenToWrap.forEach(child => contentG.appendChild(child));

  // Remove <style> blocks — they contain CSS width/height/stroke-width rules that
  // override our normalized presentation attributes in Figma and browsers.
  // All styling is now applied directly as SVG attributes, so <style> is not needed.
  contentG.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  // ── Move stroke presentation attributes from root SVG → contentG ──
  // Many icon SVGs put stroke="currentColor" stroke-width="1.5" fill="none" on root <svg>.
  // We move ALL of these to contentG so flattenToCompoundPaths can read the effective values
  // and set them explicitly on each merged path (breaking the inheritance chain cleanly).
  const STROKE_INHERIT_ATTRS = [
    'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
    'stroke-miterlimit', 'stroke-opacity', 'stroke-dasharray', 'stroke-dashoffset',
  ];
  STROKE_INHERIT_ATTRS.forEach(attr => {
    const val = outSvg.getAttribute(attr);
    if (val && !contentG.hasAttribute(attr)) contentG.setAttribute(attr, val);
    outSvg.removeAttribute(attr);
  });

  // Flatten all shape coordinates into dp space using the outer matrix [s,0,0,s,tx,ty].
  // Stroke-width is intentionally NOT changed — the source value is preserved exactly.
  walkFlatten(contentG, [s, 0, 0, s, tx, ty]);

  // Merge all shapes into flat compound paths and remove all <g> wrappers.
  // Result: icon-content → 1–N <path> elements. Figma shows a clean flat layer structure.
  // s is passed so stroke-width is scaled proportionally with the coordinate transform.
  flattenToCompoundPaths(contentG, s);

  outSvg.appendChild(contentG);

  // Remove ALL <style> elements from the entire output SVG — including any inside <defs>.
  // CSS width/height/stroke-width rules override SVG presentation attributes and cause
  // Figma to create the wrong frame size, which scales the content and makes stroke-width="1"
  // appear as a completely different value. The v2.4 fix only removed <style> from contentG;
  // this catches any <style> that survived inside <defs>.
  outSvg.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  // Remove all clip-path attributes and <clipPath> definitions.
  outSvg.querySelectorAll('[clip-path]').forEach(el => el.removeAttribute('clip-path'));
  outSvg.querySelectorAll('clipPath').forEach(el => el.parentNode.removeChild(el));

  return serializer.serializeToString(outSvg);
}

// ═══════════════════════════════════════════════════════════
// KEYLINE OVERLAY SVG (for the normalized preview)
// ═══════════════════════════════════════════════════════════

function buildKeylineOverlay(keyline, size) {
  const kl = SPEC.keylines[size][keyline];
  const pad = SPEC.padding[size];
  const color = SPEC.keylineColors[keyline];
  const cx = size / 2;
  const cy = size / 2;

  // Safe zone
  const szX = pad;
  const szY = pad;
  const szW = size - pad * 2;
  const szH = size - pad * 2;

  let keylineShape = '';
  if (keyline === 'circle') {
    const r = kl.w / 2;
    keylineShape = `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}14" stroke="${color}" stroke-width="0.25" stroke-dasharray="0.7 0.4"/>`;
  } else {
    const klX = cx - kl.w / 2;
    const klY = cy - kl.h / 2;
    keylineShape = `<rect x="${klX}" y="${klY}" width="${kl.w}" height="${kl.h}" rx="0.5" fill="${color}14" stroke="${color}" stroke-width="0.25" stroke-dasharray="0.7 0.4"/>`;
  }

  return `
    <rect x="0.1" y="0.1" width="${size - 0.2}" height="${size - 0.2}" fill="none" stroke="#c0c0c0" stroke-width="0.15"/>
    <rect x="${szX}" y="${szY}" width="${szW}" height="${szH}" fill="none" stroke="#bbb" stroke-width="0.12" stroke-dasharray="0.5 0.4"/>
    ${keylineShape}
  `;
}

// ═══════════════════════════════════════════════════════════
// PROCESSING QUEUE
// ═══════════════════════════════════════════════════════════

async function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = () => reject(new Error('Could not read file'));
    reader.readAsText(file);
  });
}

async function loadFileForProcessing(file) {
  const panel = document.getElementById('process-panel');
  const errDiv = document.getElementById('proc-error');
  errDiv.classList.remove('visible');

  try {
    const svgString = await readFileAsText(file);
    // Validate
    parseSVGString(svgString);

    state.currentRawSvg = svgString;

    // Show original preview
    const originalPreview = document.getElementById('original-preview');
    originalPreview.innerHTML = '';
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = svgString;
    const svgEl = tempDiv.querySelector('svg');
    if (svgEl) {
      svgEl.removeAttribute('width');
      svgEl.removeAttribute('height');
      svgEl.style.width = '65%';
      svgEl.style.height = '65%';
      originalPreview.appendChild(svgEl);
    }

    // Get bbox and detect keyline
    const bbox = getContentBBox(svgString);
    const detected = detectKeyline(svgString, bbox);
    state.currentKeyline = detected;
    state.currentSize = 24;

    // Populate UI
    const filename = file.name.replace('.svg', '');
    document.getElementById('icon-name').value = filename;
    document.getElementById('panel-filename').textContent = filename;

    // Bbox info
    if (bbox) {
      const ratio = (bbox.width / bbox.height).toFixed(2);
      document.getElementById('original-info').textContent =
        `${bbox.width.toFixed(1)} × ${bbox.height.toFixed(1)} (ratio ${ratio})`;
    }

    // Set keyline buttons
    updateKeylineButtons(detected);
    updateSizeButtons(24);

    // Normalize + preview
    await updateNormalizedPreview();

    panel.classList.add('visible');
    document.getElementById('save-btn').disabled = false;

  } catch (e) {
    errDiv.textContent = e.message || 'Could not process SVG';
    errDiv.classList.add('visible');
    panel.classList.add('visible');
    document.getElementById('save-btn').disabled = true;
    console.error(e);
  }
}

async function updateNormalizedPreview() {
  if (!state.currentRawSvg) return;

  const normLayer = document.getElementById('norm-icon-layer');
  const overlayEl = document.getElementById('norm-overlay-layer');
  const normInfo = document.getElementById('norm-info');

  try {
    const normalized = normalizeSVG(state.currentRawSvg, state.currentKeyline, state.currentSize);
    state.currentNormalizedSvg = normalized;

    // Show normalized icon
    normLayer.innerHTML = normalized;
    const normSvg = normLayer.querySelector('svg');
    if (normSvg) {
      normSvg.removeAttribute('width');
      normSvg.removeAttribute('height');
      normSvg.style.width = '100%';
      normSvg.style.height = '100%';
    }

    // Update overlay
    overlayEl.setAttribute('viewBox', `0 0 ${state.currentSize} ${state.currentSize}`);
    overlayEl.innerHTML = buildKeylineOverlay(state.currentKeyline, state.currentSize);
    overlayEl.style.opacity = state.overlayVisible ? '1' : '0';

    // Update info
    const kl = SPEC.keylines[state.currentSize][state.currentKeyline];
    const klLabel = state.currentKeyline === 'circle'
      ? `${kl.w}dp ⌀`
      : `${kl.w}×${kl.h}dp`;
    normInfo.textContent = `· ${klLabel} keyline · ${state.currentSize}dp canvas`;

    // Update size strip
    renderSizeStrip(normalized);

  } catch (e) {
    const errDiv = document.getElementById('proc-error');
    errDiv.textContent = 'Normalization error: ' + e.message;
    errDiv.classList.add('visible');
    state.currentNormalizedSvg = null;
    document.getElementById('save-btn').disabled = true;
    console.error(e);
  }
}

function renderSizeStrip(normalizedSvg) {
  const strip = document.getElementById('size-strip');
  const SIZES = [16, 24, 32, 48, 64];

  // Parse once and reuse the SVG, only changing display dimensions
  const parser = new DOMParser();
  const basePx = SIZES[0];

  strip.innerHTML = '';
  SIZES.forEach(px => {
    const doc = parser.parseFromString(normalizedSvg, 'image/svg+xml');
    const svg = doc.documentElement;
    // Set explicit px dimensions; keep viewBox so it renders correctly
    svg.setAttribute('width', px);
    svg.setAttribute('height', px);
    svg.style.display = 'block';
    svg.style.flexShrink = '0';

    const frame = document.createElement('div');
    frame.className = 'icon-frame';
    frame.style.width = px + 'px';
    frame.style.height = px + 'px';
    frame.appendChild(svg);

    const label = document.createElement('span');
    label.textContent = px + 'px';

    const demo = document.createElement('div');
    demo.className = 'size-demo';
    demo.appendChild(frame);
    demo.appendChild(label);
    strip.appendChild(demo);
  });
}

function updateKeylineButtons(selected) {
  document.querySelectorAll('.keyline-btn').forEach(btn => {
    const kl = btn.dataset.keyline;
    btn.classList.remove('active', 'auto-detected');
    if (kl === selected) {
      btn.classList.add('active', 'auto-detected');
    }
  });
}

function updateSizeButtons(selected) {
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.size) === selected);
  });
}

function processNextInQueue() {
  const queueBar = document.getElementById('queue-bar');
  const queue = state.queue;

  if (state.queueIndex >= queue.length) {
    // Done
    queueBar.classList.remove('visible');
    return;
  }

  // Update queue bar
  document.getElementById('queue-text').textContent =
    `Processing ${state.queueIndex + 1} of ${queue.length}`;
  renderQueueDots();
  queueBar.classList.add('visible');

  loadFileForProcessing(queue[state.queueIndex]);
}

function renderQueueDots() {
  const container = document.getElementById('queue-dots');
  const queue = state.queue;
  if (queue.length <= 1) { container.innerHTML = ''; return; }

  container.innerHTML = queue.slice(0, Math.min(queue.length, 12)).map((_, i) => {
    let cls = 'q-dot';
    if (i < state.queueIndex) cls += ' done';
    if (i === state.queueIndex) cls += ' active';
    return `<div class="${cls}"></div>`;
  }).join('');
}

// ═══════════════════════════════════════════════════════════
// LIBRARY RENDERING
// ═══════════════════════════════════════════════════════════

function renderLibrary() {
  const grid = document.getElementById('library-grid');
  const emptyState = document.getElementById('empty-state');
  const count = document.getElementById('library-count');
  const exportBtn = document.getElementById('export-zip-btn');

  const filtered = state.filter === 'all'
    ? state.library
    : state.library.filter(ic => ic.keyline === state.filter);

  count.textContent = `(${state.library.length} icon${state.library.length !== 1 ? 's' : ''})`;
  exportBtn.disabled = state.library.length === 0;

  if (filtered.length === 0) {
    grid.innerHTML = '';
    emptyState.classList.add('visible');
    const mainP = emptyState.querySelector('p');
    const hintP = emptyState.querySelector('.empty-hint');
    if (state.library.length === 0) {
      if (mainP) mainP.textContent = 'No icons yet';
      if (hintP) hintP.textContent = 'Drop SVG files above to get started';
    } else {
      if (mainP) mainP.textContent = `No ${state.filter} icons in library`;
      if (hintP) hintP.textContent = 'Try a different filter above';
    }
    return;
  }

  emptyState.classList.remove('visible');

  grid.innerHTML = filtered.map(icon => {
    const thumbSvg = icon.svgString
      .replace(/width="\d+"/, 'width="38"')
      .replace(/height="\d+"/, 'height="38"');
    const isSelected = state.selectedIds.has(icon.id);

    return `
      <div class="icon-card${isSelected ? ' selected' : ''}" data-id="${icon.id}">
        <button class="card-checkbox${isSelected ? ' checked' : ''}"
          onclick="toggleSelection(event,'${icon.id}')"
          title="Select for batch download">
          <svg width="10" height="8" viewBox="0 0 10 8" fill="none">
            <path d="M1 4l3 3 5-6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <div class="card-actions">
          <button class="card-action-btn" onclick="downloadIcon('${icon.id}')" title="Download all 3 sizes as ZIP">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
              <path d="M6 1v7M3 5l3 3 3-3M1 9v1a1 1 0 001 1h8a1 1 0 001-1V9" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="card-action-btn delete" onclick="confirmDelete('${icon.id}')" title="Delete">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
              <path d="M2 3h8M5 1h2M4 3v7M8 3v7M3 3l.5 7h5l.5-7" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
        <div class="icon-thumb">${thumbSvg}</div>
        <div class="icon-card-name">${escapeHTML(icon.name)}</div>
        <span class="keyline-badge ${icon.keyline}">${icon.keyline}</span>
        <span class="size-label">${icon.size}dp</span>
      </div>
    `;
  }).join('');
}

function escapeHTML(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ═══════════════════════════════════════════════════════════
// DOWNLOAD + EXPORT
// ═══════════════════════════════════════════════════════════

function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function addAllSizesToZip(zip, icon) {
  // Re-normalize at all 3 sizes from the original SVG (or fallback to stored normalized)
  const source = icon.originalSvg || icon.svgString;
  [16, 24, 32].forEach(sz => {
    try {
      const svg = normalizeSVG(source, icon.keyline, sz);
      zip.file(`${icon.name}/${icon.name}_${sz}dp.svg`, svg);
    } catch (e) {
      console.warn(`Could not generate ${sz}dp for ${icon.name}:`, e);
    }
  });
}

async function downloadIcon(id) {
  const icon = state.library.find(ic => ic.id === id);
  if (!icon) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded', 'error');
    return;
  }
  const zip = new JSZip();
  addAllSizesToZip(zip, icon);
  const blob = await zip.generateAsync({ type: 'blob' });
  triggerDownload(blob, `${icon.name}_${icon.keyline}.zip`);
  showToast(`"${icon.name}" downloaded — 3 sizes`);
}

async function exportAllAsZip() {
  if (state.library.length === 0) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded. Check your internet connection.', 'error');
    return;
  }

  const zip = new JSZip();
  state.library.forEach(icon => addAllSizesToZip(zip, icon));

  const btn = document.getElementById('export-zip-btn');
  btn.textContent = 'Generating…';
  btn.disabled = true;

  try {
    const blob = await zip.generateAsync({ type: 'blob' });
    triggerDownload(blob, `icons_${new Date().toISOString().slice(0,10)}.zip`);
    showToast(`Exported ${state.library.length} icons (3 sizes each)`);
  } catch (e) {
    showToast('Export failed: ' + e.message, 'error');
  } finally {
    btn.textContent = 'Export all as ZIP';
    btn.disabled = state.library.length === 0;
  }}

function confirmDelete(id) {
  const icon = state.library.find(ic => ic.id === id);
  if (!icon) return;
  if (confirm(`Delete "${icon.name}"?`)) {
    state.selectedIds.delete(id);
    updateSelectionBar();
    deleteFromLibrary(id);
  }
}

// ── Overlay toggle ──
function setupOverlayToggle() {
  document.getElementById('overlay-toggle').addEventListener('click', () => {
    state.overlayVisible = !state.overlayVisible;
    const btn = document.getElementById('overlay-toggle');
    btn.classList.toggle('active', state.overlayVisible);
    document.getElementById('norm-overlay-layer').style.opacity = state.overlayVisible ? '1' : '0';
  });
}

// ── Selection + batch download ──
function toggleSelection(event, id) {
  event.stopPropagation();
  if (state.selectedIds.has(id)) {
    state.selectedIds.delete(id);
  } else {
    state.selectedIds.add(id);
  }
  // Update just this card without full re-render
  const card = document.querySelector(`.icon-card[data-id="${id}"]`);
  if (card) {
    const isNowSelected = state.selectedIds.has(id);
    card.classList.toggle('selected', isNowSelected);
    const cb = card.querySelector('.card-checkbox');
    if (cb) cb.classList.toggle('checked', isNowSelected);
  }
  updateSelectionBar();
}

function updateSelectionBar() {
  const bar = document.getElementById('selection-bar');
  const count = state.selectedIds.size;
  if (count === 0) {
    bar.classList.remove('visible');
  } else {
    bar.classList.add('visible');
    document.getElementById('sel-count').textContent =
      `${count} icon${count !== 1 ? 's' : ''} selected`;
  }
}

function clearSelection() {
  state.selectedIds.clear();
  document.querySelectorAll('.icon-card.selected').forEach(card => {
    card.classList.remove('selected');
    const cb = card.querySelector('.card-checkbox');
    if (cb) cb.classList.remove('checked');
  });
  updateSelectionBar();
}

async function downloadSelected() {
  if (state.selectedIds.size === 0) return;
  if (typeof JSZip === 'undefined') {
    showToast('JSZip not loaded', 'error');
    return;
  }
  const btn = document.getElementById('sel-download-btn');
  btn.textContent = 'Generating…';
  btn.disabled = true;

  try {
    const zip = new JSZip();
    const ids = Array.from(state.selectedIds);
    ids.forEach(id => {
      const icon = state.library.find(ic => ic.id === id);
      if (icon) addAllSizesToZip(zip, icon);
    });
    const blob = await zip.generateAsync({ type: 'blob' });
    triggerDownload(blob, `icons_selected_${new Date().toISOString().slice(0,10)}.zip`);
    showToast(`Downloaded ${ids.length} icon${ids.length !== 1 ? 's' : ''} (3 sizes each)`);
    clearSelection();
  } catch (e) {
    showToast('Download failed: ' + e.message, 'error');
  } finally {
    btn.textContent = '↓ Download (all 3 sizes)';
    btn.disabled = false;
  }
}

function setupSelectionBar() {
  document.getElementById('sel-download-btn').addEventListener('click', downloadSelected);
  document.getElementById('sel-clear-btn').addEventListener('click', clearSelection);
}

// ═══════════════════════════════════════════════════════════
// TOAST
// ═══════════════════════════════════════════════════════════

let toastTimeout;
function showToast(msg, type = 'default') {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className = type !== 'default' ? type : '';
  el.classList.add('show');
  clearTimeout(toastTimeout);
  toastTimeout = setTimeout(() => el.classList.remove('show'), 2800);
}

// ═══════════════════════════════════════════════════════════
// EVENT WIRING
// ═══════════════════════════════════════════════════════════

function setupUploadZone() {
  const dropArea = document.getElementById('drop-area');
  const fileInput = document.getElementById('file-input');
  const browseLink = document.getElementById('browse-link');

  browseLink.addEventListener('click', () => fileInput.click());
  dropArea.addEventListener('click', e => {
    if (e.target !== browseLink) fileInput.click();
  });

  fileInput.addEventListener('change', e => {
    handleFiles(Array.from(e.target.files));
    fileInput.value = ''; // reset so same file can be re-uploaded
  });

  dropArea.addEventListener('dragover', e => {
    e.preventDefault();
    dropArea.classList.add('drag-over');
  });
  dropArea.addEventListener('dragleave', () => dropArea.classList.remove('drag-over'));
  dropArea.addEventListener('drop', e => {
    e.preventDefault();
    dropArea.classList.remove('drag-over');
    const svgFiles = Array.from(e.dataTransfer.files).filter(f =>
      f.name.endsWith('.svg') || f.type === 'image/svg+xml'
    );
    if (svgFiles.length === 0) {
      showToast('Please drop SVG files', 'error');
      return;
    }
    handleFiles(svgFiles);
  });
}

function handleFiles(files) {
  const svgFiles = files.filter(f => f.name.endsWith('.svg') || f.type === 'image/svg+xml');
  if (svgFiles.length === 0) {
    showToast('No SVG files found', 'error');
    return;
  }
  state.queue = svgFiles;
  state.queueIndex = 0;
  processNextInQueue();
}

function setupKeylineButtons() {
  document.querySelectorAll('.keyline-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const kl = btn.dataset.keyline;
      state.currentKeyline = kl;
      // Remove auto-detected badge from all, mark selected
      document.querySelectorAll('.keyline-btn').forEach(b => {
        b.classList.remove('active', 'auto-detected');
      });
      btn.classList.add('active');
      await updateNormalizedPreview();
    });
  });
}

function setupSizeButtons() {
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      state.currentSize = parseInt(btn.dataset.size);
      updateSizeButtons(state.currentSize);
      await updateNormalizedPreview();
    });
  });
}

function setupSaveButton() {
  document.getElementById('save-btn').addEventListener('click', () => {
    if (!state.currentNormalizedSvg) return;

    const name = (document.getElementById('icon-name').value || 'icon').trim();
    const icon = {
      id: 'icon_' + Date.now() + '_' + Math.random().toString(36).slice(2, 7),
      name,
      keyline: state.currentKeyline,
      size: state.currentSize,
      svgString: state.currentNormalizedSvg,
      originalSvg: state.currentRawSvg,   // stored for multi-size re-export
      createdAt: new Date().toISOString(),
      animations: [], // v2 placeholder
    };

    addToLibrary(icon);
    renderLibrary();
    showToast(`"${name}" saved to library`, 'success');

    // Advance queue
    state.queueIndex++;
    if (state.queueIndex < state.queue.length) {
      processNextInQueue();
    } else {
      document.getElementById('queue-bar').classList.remove('visible');
      document.getElementById('process-panel').classList.remove('visible');
    }
  });
}

function setupSkipButton() {
  document.getElementById('skip-btn').addEventListener('click', () => {
    state.queueIndex++;
    document.getElementById('proc-error').classList.remove('visible');
    if (state.queueIndex < state.queue.length) {
      processNextInQueue();
    } else {
      document.getElementById('queue-bar').classList.remove('visible');
      document.getElementById('process-panel').classList.remove('visible');
    }
  });
}

function setupFilterButtons() {
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.filter = btn.dataset.filter;
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      renderLibrary();
    });
  });
}

function setupSpecToggle() {
  const btn = document.getElementById('spec-toggle-btn');
  const panel = document.getElementById('spec-panel');
  btn.addEventListener('click', () => {
    const isOpen = panel.classList.toggle('open');
    btn.classList.toggle('open', isOpen);
    btn.querySelector('span') && (btn.querySelector('span').textContent = isOpen ? 'Hide spec' : 'Spec reference');
  });
}

function setupExportButton() {
  document.getElementById('export-zip-btn').addEventListener('click', exportAllAsZip);
}

// ═══════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════

function init() {
  loadLibrary();
  setupUploadZone();
  setupKeylineButtons();
  setupSizeButtons();
  setupSaveButton();
  setupSkipButton();
  setupFilterButtons();
  setupSpecToggle();
  setupExportButton();
  setupOverlayToggle();
  setupSelectionBar();
  renderLibrary();
}

document.addEventListener('DOMContentLoaded', init);

// ═══════════════════════════════════════════════════════════
// ANIMATIONS
// ═══════════════════════════════════════════════════════════

// Stagger card entrance when library grid re-renders
function animateCards() {
  const cards = document.querySelectorAll('#library-grid .icon-card');
  cards.forEach((card, i) => {
    card.classList.remove('card-anim');
    void card.offsetWidth; // force reflow
    card.style.animationDelay = (i * 45) + 'ms';
    card.classList.add('card-anim');
  });
}

// Patch renderLibrary to call animateCards after render
const _origRenderLibrary = renderLibrary;
renderLibrary = function() {
  _origRenderLibrary.apply(this, arguments);
  requestAnimationFrame(animateCards);
};

// Upload icon: scale to 1 on drop-area click interaction
document.addEventListener('DOMContentLoaded', () => {
  const dropArea = document.getElementById('drop-area');
  if (dropArea) {
    dropArea.addEventListener('dragenter', () => dropArea.classList.add('drag-over'));
    dropArea.addEventListener('dragleave', () => dropArea.classList.remove('drag-over'));
    dropArea.addEventListener('drop', () => setTimeout(() => dropArea.classList.remove('drag-over'), 200));
  }
});
</script>
</body>
</html>
