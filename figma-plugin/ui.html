<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 12px;
    color: #333;
    padding: 16px;
    background: #fff;
    display: flex;
    flex-direction: column;
    gap: 14px;
    min-height: 100vh;
  }
  h2 {
    font-size: 15px;
    font-weight: 700;
    color: #0a2540;
    letter-spacing: -0.3px;
  }
  .subtitle {
    font-size: 11px;
    color: #8898aa;
    margin-top: 2px;
  }
  #progress-section { display: none; }
  #progress-section.visible { display: block; }
  .progress-track {
    width: 100%;
    height: 4px;
    background: #e3e8ee;
    border-radius: 2px;
    overflow: hidden;
    margin-top: 10px;
  }
  .progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #635BFF, #ed5f74);
    border-radius: 2px;
    transition: width 0.3s ease;
  }
  #status {
    font-size: 11px;
    color: #425466;
    margin-top: 6px;
  }
  #count {
    font-size: 11px;
    color: #8898aa;
    margin-top: 2px;
  }
  #done-section { display: none; }
  #done-section.visible { display: block; }
  .done-msg {
    font-size: 13px;
    font-weight: 600;
    color: #0DBD8B;
  }
  .error-msg {
    font-size: 11px;
    color: #DF1B41;
    margin-top: 4px;
  }
  #waiting {
    font-size: 11px;
    color: #8898aa;
    text-align: center;
    padding: 20px 0;
  }
</style>
</head>
<body>

<!-- Hidden sandbox for getBBox() -->
<div id="svg-sandbox" style="position:absolute;left:-9999px;top:-9999px;visibility:hidden;pointer-events:none;width:200px;height:200px;"></div>

<div>
  <h2>Icon Normalizer</h2>
  <p class="subtitle">Normalizes to 16dp / 24dp / 32dp with 1dp line weight</p>
</div>

<div id="waiting">Waiting for icons...</div>

<div id="progress-section">
  <div class="progress-track">
    <div class="progress-fill" id="progress-fill"></div>
  </div>
  <p id="status"></p>
  <p id="count"></p>
</div>

<div id="done-section">
  <p class="done-msg" id="done-msg"></p>
  <p class="error-msg" id="error-msg"></p>
</div>

<script>
// ═══════════════════════════════════════════════════════════
// SPEC DATA
// ═══════════════════════════════════════════════════════════
const SPEC = {
  keylines: {
    16: {
      circle:     { w: 14, h: 14 },
      square:     { w: 12, h: 12 },
      vertical:   { w: 10, h: 14 },
      horizontal: { w: 14, h: 10 },
    },
    24: {
      circle:     { w: 20, h: 20 },
      square:     { w: 18, h: 18 },
      vertical:   { w: 16, h: 20 },
      horizontal: { w: 20, h: 16 },
    },
    32: {
      circle:     { w: 28, h: 28 },
      square:     { w: 26, h: 26 },
      vertical:   { w: 24, h: 28 },
      horizontal: { w: 28, h: 24 },
    },
  },
  padding: { 16: 1, 24: 2, 32: 2 },
};

// ═══════════════════════════════════════════════════════════
// TRANSFORM MATH + PATH FLATTENING
// ═══════════════════════════════════════════════════════════

function matMul(p, q) {
  return [
    p[0]*q[0]+p[2]*q[1], p[1]*q[0]+p[3]*q[1],
    p[0]*q[2]+p[2]*q[3], p[1]*q[2]+p[3]*q[3],
    p[0]*q[4]+p[2]*q[5]+p[4], p[1]*q[4]+p[3]*q[5]+p[5],
  ];
}
function matApply(m, x, y) { return [m[0]*x+m[2]*y+m[4], m[1]*x+m[3]*y+m[5]]; }
function matScale(m) { return Math.sqrt(m[0]*m[0]+m[1]*m[1]); }

function parseTransformStr(s) {
  if (!s) return [1,0,0,1,0,0];
  let m = [1,0,0,1,0,0];
  const re = /(\w+)\s*\(([^)]*)\)/g;
  let match;
  while ((match = re.exec(s)) !== null) {
    const fn = match[1];
    const a = match[2].trim().split(/[\s,]+/).map(Number);
    let t = [1,0,0,1,0,0];
    if      (fn==='translate') t = [1,0,0,1,a[0]||0,a[1]||0];
    else if (fn==='scale')     { const sx=a[0]||1,sy=a.length>1?a[1]:sx; t=[sx,0,0,sy,0,0]; }
    else if (fn==='matrix')    t = a.slice(0,6);
    else if (fn==='rotate') {
      const ang=(a[0]||0)*Math.PI/180, cos=Math.cos(ang), sin=Math.sin(ang);
      const cx=a[1]||0, cy=a[2]||0;
      t = [cos, sin, -sin, cos, cx-cos*cx+sin*cy, cy-sin*cx-cos*cy];
    }
    m = matMul(m, t);
  }
  return m;
}

function transformPathD(d, m) {
  if (!d) return d;
  const tokens = [];
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match;
  while ((match = re.exec(d)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const out = [];
  let i = 0, cx = 0, cy = 0, sx = 0, sy = 0, prevCmd = 'M';
  const n = () => tokens[i++];
  const f = v => parseFloat(v.toFixed(4));

  while (i < tokens.length) {
    let cmd = typeof tokens[i] === 'string' ? (prevCmd = tokens[i++]) : prevCmd;
    const C = cmd.toUpperCase(), rel = cmd !== C;

    if (C === 'Z') { out.push('Z'); cx=sx; cy=sy; continue; }

    if (C === 'M') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`M${f(nx)},${f(ny)}`);
      cx=x;cy=y;sx=x;sy=y; prevCmd=rel?'l':'L';
    } else if (C === 'L') {
      let x=n(), y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`L${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'H') {
      let x=n(); if (rel) x+=cx;
      const [nx,ny]=matApply(m,x,cy); out.push(`L${f(nx)},${f(ny)}`); cx=x;
    } else if (C === 'V') {
      let y=n(); if (rel) y+=cy;
      const [nx,ny]=matApply(m,cx,y); out.push(`L${f(nx)},${f(ny)}`); cy=y;
    } else if (C === 'C') {
      let x1=n(),y1=n(),x2=n(),y2=n(),x=n(),y=n();
      if (rel){x1+=cx;y1+=cy;x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`C${f(a1)},${f(b1)},${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'S') {
      let x2=n(),y2=n(),x=n(),y=n(); if (rel){x2+=cx;y2+=cy;x+=cx;y+=cy;}
      const [a2,b2]=matApply(m,x2,y2),[nx,ny]=matApply(m,x,y);
      out.push(`S${f(a2)},${f(b2)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'Q') {
      let x1=n(),y1=n(),x=n(),y=n(); if (rel){x1+=cx;y1+=cy;x+=cx;y+=cy;}
      const [a1,b1]=matApply(m,x1,y1),[nx,ny]=matApply(m,x,y);
      out.push(`Q${f(a1)},${f(b1)},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'T') {
      let x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const [nx,ny]=matApply(m,x,y); out.push(`T${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else if (C === 'A') {
      let rx=n(),ry=n(),rot=n(),la=n(),sw=n(),x=n(),y=n(); if (rel){x+=cx;y+=cy;}
      const sc=matScale(m), [nx,ny]=matApply(m,x,y);
      out.push(`A${f(rx*sc)},${f(ry*sc)},${rot},${la},${sw},${f(nx)},${f(ny)}`); cx=x;cy=y;
    } else { while (i<tokens.length && typeof tokens[i]==='number') i++; }
  }
  return out.join(' ');
}

// ═══════════════════════════════════════════════════════════
// ELEMENT FLATTENING
// ═══════════════════════════════════════════════════════════

const FLATTEN_TAGS = new Set(['path','line','circle','ellipse','rect','polyline','polygon']);

function flattenElement(el, m) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v.toFixed(4));
  const sc = matScale(m);
  if (tag === 'path') {
    const d = el.getAttribute('d'); if (d) el.setAttribute('d', transformPathD(d, m));
  } else if (tag === 'line') {
    const [nx1,ny1]=matApply(m,+(el.getAttribute('x1')||0),+(el.getAttribute('y1')||0));
    const [nx2,ny2]=matApply(m,+(el.getAttribute('x2')||0),+(el.getAttribute('y2')||0));
    el.setAttribute('x1',f(nx1));el.setAttribute('y1',f(ny1));
    el.setAttribute('x2',f(nx2));el.setAttribute('y2',f(ny2));
  } else if (tag === 'circle') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('r',f(+(el.getAttribute('r')||0)*sc));
  } else if (tag === 'ellipse') {
    const [nx,ny]=matApply(m,+(el.getAttribute('cx')||0),+(el.getAttribute('cy')||0));
    el.setAttribute('cx',f(nx));el.setAttribute('cy',f(ny));
    el.setAttribute('rx',f(+(el.getAttribute('rx')||0)*sc));
    el.setAttribute('ry',f(+(el.getAttribute('ry')||0)*sc));
  } else if (tag === 'rect') {
    const [nx,ny]=matApply(m,+(el.getAttribute('x')||0),+(el.getAttribute('y')||0));
    el.setAttribute('x',f(nx));el.setAttribute('y',f(ny));
    el.setAttribute('width',f(+(el.getAttribute('width')||0)*sc));
    el.setAttribute('height',f(+(el.getAttribute('height')||0)*sc));
    const rx=el.getAttribute('rx'),ry=el.getAttribute('ry');
    if (rx) el.setAttribute('rx',f(+rx*sc));
    if (ry) el.setAttribute('ry',f(+ry*sc));
  } else if (tag === 'polyline' || tag === 'polygon') {
    const pts=(el.getAttribute('points')||'').trim().split(/[\s,]+/).map(Number);
    const out=[];
    for (let k=0;k<pts.length-1;k+=2){const[nx,ny]=matApply(m,pts[k],pts[k+1]);out.push(`${f(nx)},${f(ny)}`);}
    el.setAttribute('points',out.join(' '));
  }
  el.removeAttribute('transform');
}

function walkFlatten(node, parentMat) {
  if (node.nodeType !== 1) return;
  const tag = node.tagName.toLowerCase();
  if (FLATTEN_TAGS.has(tag)) {
    const elMat = parseTransformStr(node.getAttribute('transform'));
    flattenElement(node, matMul(parentMat, elMat));
  } else {
    const groupMat = (tag === 'g' || tag === 'svg')
      ? matMul(parentMat, parseTransformStr(node.getAttribute('transform')))
      : parentMat;
    if (tag === 'g') node.removeAttribute('transform');
    Array.from(node.childNodes).forEach(child => walkFlatten(child, groupMat));
  }
}

// ═══════════════════════════════════════════════════════════
// SVG PARSING
// ═══════════════════════════════════════════════════════════

function parseSVGString(svgString) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgString, 'image/svg+xml');
  const root = doc.documentElement;
  if (root.querySelector('parsererror')) {
    throw new Error('Invalid SVG — parse error');
  }
  if (root.tagName.toLowerCase() !== 'svg') {
    throw new Error('File does not contain an SVG root element');
  }
  return { doc, root };
}

function ensureViewBox(svgEl) {
  const vb = svgEl.viewBox && svgEl.viewBox.baseVal;
  if (vb && vb.width > 0 && vb.height > 0) {
    return { x: vb.x, y: vb.y, w: vb.width, h: vb.height };
  }
  const w = parseFloat(svgEl.getAttribute('width')) || 24;
  const h = parseFloat(svgEl.getAttribute('height')) || 24;
  svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
  return { x: 0, y: 0, w, h };
}

function getContentBBox(svgString) {
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  if (!liveSvg) return null;

  liveSvg.removeAttribute('width');
  liveSvg.removeAttribute('height');
  liveSvg.style.width = '200px';
  liveSvg.style.height = '200px';

  const vbInfo = ensureViewBox(liveSvg);

  const tempG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  const drawable = Array.from(liveSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  drawable.forEach(child => tempG.appendChild(child.cloneNode(true)));
  liveSvg.appendChild(tempG);

  let bbox = null;
  try {
    bbox = tempG.getBBox();
  } catch (e) { /* getBBox not available */ }

  liveSvg.removeChild(tempG);
  sandbox.innerHTML = '';

  if (!bbox || bbox.width === 0 || bbox.height === 0) {
    return { x: vbInfo.x, y: vbInfo.y, width: vbInfo.w, height: vbInfo.h, vbInfo };
  }

  return { x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height, vbInfo };
}

// Geometric circle test — render a closed subpath in a temp SVG,
// sample 12 points with getPointAtLength, check if all are
// equidistant from center (i.e. the shape is circular).
function isSubpathCircular(subD, sandbox) {
  const ns = 'http://www.w3.org/2000/svg';
  const tempSvg = document.createElementNS(ns, 'svg');
  tempSvg.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden';
  const tempPath = document.createElementNS(ns, 'path');
  tempPath.setAttribute('d', subD);
  tempSvg.appendChild(tempPath);
  sandbox.appendChild(tempSvg);

  let circular = false;
  try {
    const bb = tempPath.getBBox();
    if (bb.width > 0 && bb.height > 0) {
      const ratio = bb.width / bb.height;
      if (Math.abs(ratio - 1) < 0.15) {
        const cx = bb.x + bb.width / 2;
        const cy = bb.y + bb.height / 2;
        const expectedR = (bb.width + bb.height) / 4;
        const totalLen = tempPath.getTotalLength();
        if (totalLen > 0 && expectedR > 0) {
          circular = true;
          for (let i = 0; i < 12; i++) {
            const pt = tempPath.getPointAtLength((i / 12) * totalLen);
            const dist = Math.sqrt((pt.x - cx) ** 2 + (pt.y - cy) ** 2);
            if (Math.abs(dist - expectedR) / expectedR > 0.12) {
              circular = false;
              break;
            }
          }
        }
      }
    }
  } catch (_) {}

  tempSvg.remove();
  return circular;
}

function detectKeyline(svgString, bbox) {
  const sandbox = document.getElementById('svg-sandbox');
  sandbox.innerHTML = svgString;
  const liveSvg = sandbox.querySelector('svg');
  let hasCircleShape = false;

  // Collect path d-attributes while the SVG is in the DOM
  const pathDatas = [];

  if (liveSvg) {
    // 1. Direct <circle> elements
    const circles = liveSvg.querySelectorAll('circle');
    const otherShapes = liveSvg.querySelectorAll('path, rect, line, polyline, polygon');
    if (circles.length > 0 && otherShapes.length <= 1) hasCircleShape = true;

    // 2. <ellipse> elements with nearly equal rx/ry
    if (!hasCircleShape) {
      for (const el of liveSvg.querySelectorAll('ellipse')) {
        const rx = parseFloat(el.getAttribute('rx') || 0);
        const ry = parseFloat(el.getAttribute('ry') || 0);
        if (rx > 0 && ry > 0 && Math.abs(rx / ry - 1) < 0.15) {
          hasCircleShape = true;
          break;
        }
      }
    }

    // Collect path data for geometric check (step 3)
    if (!hasCircleShape) {
      for (const p of liveSvg.querySelectorAll('path')) {
        const d = p.getAttribute('d') || '';
        if (d) pathDatas.push(d);
      }
    }
  }
  sandbox.innerHTML = '';

  // 3. Geometric circle detection — split compound paths into subpaths,
  //    render each in a temp SVG, sample points to check circularity.
  //    Works for arcs, cubic beziers, or any curve that forms a circle.
  if (!hasCircleShape && pathDatas.length > 0) {
    for (const d of pathDatas) {
      const subpaths = d.split(/(?=[Mm])/).filter(s => s.trim());
      for (const sub of subpaths) {
        if (!/[Zz]/.test(sub)) continue; // only closed subpaths
        if (isSubpathCircular(sub, sandbox)) {
          hasCircleShape = true;
          break;
        }
      }
      if (hasCircleShape) break;
    }
  }

  if (!bbox || bbox.width === 0 || bbox.height === 0) return 'square';

  const ratio = bbox.width / bbox.height;
  const isSquarish = Math.abs(ratio - 1) < 0.15;

  if (isSquarish && hasCircleShape) return 'circle';
  if (isSquarish) return 'square';
  if (ratio < 0.85) return 'vertical';
  if (ratio > 1.15) return 'horizontal';
  return 'square';
}

// ═══════════════════════════════════════════════════════════
// SHAPE CONVERSION
// ═══════════════════════════════════════════════════════════

function shapeToPathD(el) {
  const tag = el.tagName.toLowerCase();
  const f = v => parseFloat(v || 0);

  if (tag === 'path') return el.getAttribute('d') || '';

  if (tag === 'line') {
    const x1 = f(el.getAttribute('x1')), y1 = f(el.getAttribute('y1'));
    const x2 = f(el.getAttribute('x2')), y2 = f(el.getAttribute('y2'));
    return `M ${x1} ${y1} L ${x2} ${y2}`;
  }

  if (tag === 'rect') {
    const x = f(el.getAttribute('x')), y = f(el.getAttribute('y'));
    const w = f(el.getAttribute('width')), h = f(el.getAttribute('height'));
    const rx = Math.min(f(el.getAttribute('rx')), w / 2);
    const ry = Math.min(f(el.getAttribute('ry') || el.getAttribute('rx')), h / 2);
    if (rx === 0 && ry === 0) return `M ${x} ${y} H ${x + w} V ${y + h} H ${x} Z`;
    return `M ${x + rx} ${y} H ${x + w - rx} A ${rx} ${ry} 0 0 1 ${x + w} ${y + ry} V ${y + h - ry} A ${rx} ${ry} 0 0 1 ${x + w - rx} ${y + h} H ${x + rx} A ${rx} ${ry} 0 0 1 ${x} ${y + h - ry} V ${y + ry} A ${rx} ${ry} 0 0 1 ${x + rx} ${y} Z`;
  }

  if (tag === 'circle') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const r = f(el.getAttribute('r'));
    return `M ${cx - r} ${cy} A ${r} ${r} 0 1 0 ${cx + r} ${cy} A ${r} ${r} 0 1 0 ${cx - r} ${cy} Z`;
  }

  if (tag === 'ellipse') {
    const cx = f(el.getAttribute('cx')), cy = f(el.getAttribute('cy'));
    const rx2 = f(el.getAttribute('rx')), ry2 = f(el.getAttribute('ry'));
    return `M ${cx - rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx + rx2} ${cy} A ${rx2} ${ry2} 0 1 0 ${cx - rx2} ${cy} Z`;
  }

  if (tag === 'polyline' || tag === 'polygon') {
    const pts = (el.getAttribute('points') || '').trim().split(/[\s,]+/);
    const pairs = [];
    for (let i = 0; i + 1 < pts.length; i += 2) pairs.push(`${pts[i]} ${pts[i + 1]}`);
    if (!pairs.length) return '';
    const d = `M ${pairs.join(' L ')}`;
    return tag === 'polygon' ? d + ' Z' : d;
  }
  return '';
}

function isClosedPath(d) {
  return /[Zz]\s*$/.test((d || '').trim());
}

function makeInnerDFromPath(outerD) {
  const re = /([MmLlHhVvCcSsQqTtAaZz])|([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?)/g;
  let match, cx = 0, cy = 0, cmd = 'M';
  const tokens = [];
  while ((match = re.exec(outerD)) !== null)
    tokens.push(match[1] !== undefined ? match[1] : parseFloat(match[2]));

  const coords = [];
  let i = 0;
  while (i < tokens.length) {
    if (typeof tokens[i] === 'string') { cmd = tokens[i++]; continue; }
    const C = cmd.toUpperCase(), rel = cmd !== C;
    if (C === 'Z') continue;
    if (C === 'M' || C === 'L' || C === 'T') {
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'H') {
      let x = tokens[i++]; if (rel) x += cx; cx = x;
      coords.push([cx, cy]);
    } else if (C === 'V') {
      let y = tokens[i++]; if (rel) y += cy; cy = y;
      coords.push([cx, cy]);
    } else if (C === 'C') {
      for (let j = 0; j < 3; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 2) { cx = x; cy = y; }
      }
    } else if (C === 'S' || C === 'Q') {
      for (let j = 0; j < 2; j++) {
        let x = tokens[i++], y = tokens[i++];
        if (rel) { x += cx; y += cy; }
        coords.push([x, y]);
        if (j === 1) { cx = x; cy = y; }
      }
    } else if (C === 'A') {
      i += 5;
      let x = tokens[i++], y = tokens[i++];
      if (rel) { x += cx; y += cy; } cx = x; cy = y;
      coords.push([cx, cy]);
    } else { i++; }
  }

  if (coords.length < 2) return '';
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  coords.forEach(([x, y]) => {
    if (x < minX) minX = x; if (x > maxX) maxX = x;
    if (y < minY) minY = y; if (y > maxY) maxY = y;
  });
  const w = maxX - minX, h = maxY - minY;
  if (w <= 2 || h <= 2) return '';

  const cxB = minX + w / 2, cyB = minY + h / 2;
  const sxF = (w - 2) / w, syF = (h - 2) / h;
  const mat = [sxF, 0, 0, syF, cxB * (1 - sxF), cyB * (1 - syF)];
  return transformPathD(outerD, mat);
}

// ═══════════════════════════════════════════════════════════
// STROKE-TO-FILL CONVERSION
// ═══════════════════════════════════════════════════════════

// Convert a stroked path to a filled outline path using point sampling.
// Samples points along the path, computes perpendicular normals, offsets
// outward/inward by half the stroke-width. Returns a fill-only d-string.
//   - Closed paths → evenodd ring (outer + reversed inner contours)
//   - Open paths → single closed contour (outer → end cap → inner reversed → start cap)
function strokeToFillPath(pathD, strokeWidth, linecap, linejoin, miterlimit, sandbox) {
  if (!pathD || strokeWidth < 0.001) return '';

  const ns = 'http://www.w3.org/2000/svg';
  const tempSvg = document.createElementNS(ns, 'svg');
  tempSvg.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden';
  const tempPath = document.createElementNS(ns, 'path');
  tempPath.setAttribute('d', pathD);
  tempSvg.appendChild(tempPath);
  sandbox.appendChild(tempSvg);

  let result = '';
  try {
    const totalLen = tempPath.getTotalLength();
    if (totalLen < 0.001) { tempSvg.remove(); return ''; }

    const closed = /[Zz]\s*$/.test(pathD.trim());
    const halfW = strokeWidth / 2;
    const numSamples = Math.max(16, Math.round(totalLen * 4));
    const dt = Math.min(0.05, totalLen * 0.0005);
    const f = v => parseFloat(v.toFixed(4));

    const outerPts = [];
    const innerPts = [];

    for (let i = 0; i <= numSamples; i++) {
      const t = Math.min((i / numSamples) * totalLen, totalLen);
      const pt = tempPath.getPointAtLength(t);

      const t0 = Math.max(0, t - dt);
      const t1 = Math.min(totalLen, t + dt);
      const p0 = tempPath.getPointAtLength(t0);
      const p1 = tempPath.getPointAtLength(t1);
      const tdx = p1.x - p0.x;
      const tdy = p1.y - p0.y;
      const tlen = Math.sqrt(tdx * tdx + tdy * tdy);

      let nx, ny;
      if (tlen < 1e-10) {
        if (outerPts.length > 0) {
          const prevO = outerPts[outerPts.length - 1];
          const prevI = innerPts[innerPts.length - 1];
          nx = (prevO.x - prevI.x); ny = (prevO.y - prevI.y);
          const nl = Math.sqrt(nx * nx + ny * ny);
          if (nl > 1e-10) { nx /= nl; ny /= nl; }
          else { nx = 0; ny = -1; }
        } else { nx = 0; ny = -1; }
      } else {
        nx = -tdy / tlen;
        ny = tdx / tlen;
      }

      outerPts.push({ x: pt.x + nx * halfW, y: pt.y + ny * halfW });
      innerPts.push({ x: pt.x - nx * halfW, y: pt.y - ny * halfW });
    }

    // For open paths, extend endpoints along the tangent direction so adjacent
    // fill outlines overlap at junctions instead of leaving anti-aliasing gaps.
    if (!closed) {
      const EXT = halfW; // extend by half the stroke width at each end

      // Start extension (backward along path direction)
      const s0 = tempPath.getPointAtLength(0);
      const s1 = tempPath.getPointAtLength(Math.min(dt * 2, totalLen));
      let bx = s0.x - s1.x, by = s0.y - s1.y;
      const bl = Math.sqrt(bx * bx + by * by);
      if (bl > 1e-10) { bx /= bl; by /= bl; } else { bx = 0; by = 0; }
      outerPts.unshift({ x: outerPts[0].x + bx * EXT, y: outerPts[0].y + by * EXT });
      innerPts.unshift({ x: innerPts[0].x + bx * EXT, y: innerPts[0].y + by * EXT });

      // End extension (forward along path direction)
      const e0 = tempPath.getPointAtLength(totalLen);
      const e1 = tempPath.getPointAtLength(Math.max(0, totalLen - dt * 2));
      let fx = e0.x - e1.x, fy = e0.y - e1.y;
      const fl = Math.sqrt(fx * fx + fy * fy);
      if (fl > 1e-10) { fx /= fl; fy /= fl; } else { fx = 0; fy = 0; }
      outerPts.push({ x: outerPts[outerPts.length - 1].x + fx * EXT, y: outerPts[outerPts.length - 1].y + fy * EXT });
      innerPts.push({ x: innerPts[innerPts.length - 1].x + fx * EXT, y: innerPts[innerPts.length - 1].y + fy * EXT });
    }

    if (closed) {
      let d = `M${f(outerPts[0].x)},${f(outerPts[0].y)}`;
      for (let i = 1; i < outerPts.length; i++) {
        d += ` L${f(outerPts[i].x)},${f(outerPts[i].y)}`;
      }
      d += ' Z';
      const last = innerPts.length - 1;
      d += ` M${f(innerPts[last].x)},${f(innerPts[last].y)}`;
      for (let i = last - 1; i >= 0; i--) {
        d += ` L${f(innerPts[i].x)},${f(innerPts[i].y)}`;
      }
      d += ' Z';
      result = d;
    } else {
      let d = `M${f(outerPts[0].x)},${f(outerPts[0].y)}`;
      for (let i = 1; i < outerPts.length; i++) {
        d += ` L${f(outerPts[i].x)},${f(outerPts[i].y)}`;
      }

      const endO = outerPts[outerPts.length - 1];
      const endI = innerPts[innerPts.length - 1];
      if (linecap === 'round') {
        d += ` A${f(halfW)},${f(halfW)} 0 0 1 ${f(endI.x)},${f(endI.y)}`;
      } else if (linecap === 'square') {
        const lastPt = tempPath.getPointAtLength(totalLen);
        const prevPt = tempPath.getPointAtLength(Math.max(0, totalLen - dt));
        let tx = lastPt.x - prevPt.x, ty = lastPt.y - prevPt.y;
        const tl = Math.sqrt(tx * tx + ty * ty);
        if (tl > 1e-10) { tx /= tl; ty /= tl; } else { tx = 1; ty = 0; }
        d += ` L${f(endO.x + tx * halfW)},${f(endO.y + ty * halfW)}`;
        d += ` L${f(endI.x + tx * halfW)},${f(endI.y + ty * halfW)}`;
        d += ` L${f(endI.x)},${f(endI.y)}`;
      } else {
        d += ` L${f(endI.x)},${f(endI.y)}`;
      }

      for (let i = innerPts.length - 2; i >= 0; i--) {
        d += ` L${f(innerPts[i].x)},${f(innerPts[i].y)}`;
      }

      const startO = outerPts[0];
      const startI = innerPts[0];
      if (linecap === 'round') {
        d += ` A${f(halfW)},${f(halfW)} 0 0 1 ${f(startO.x)},${f(startO.y)}`;
      } else if (linecap === 'square') {
        const firstPt = tempPath.getPointAtLength(0);
        const nextPt = tempPath.getPointAtLength(Math.min(dt, totalLen));
        let tx = firstPt.x - nextPt.x, ty = firstPt.y - nextPt.y;
        const tl = Math.sqrt(tx * tx + ty * ty);
        if (tl > 1e-10) { tx /= tl; ty /= tl; } else { tx = -1; ty = 0; }
        d += ` L${f(startI.x + tx * halfW)},${f(startI.y + ty * halfW)}`;
        d += ` L${f(startO.x + tx * halfW)},${f(startO.y + ty * halfW)}`;
      }
      d += ' Z';
      result = d;
    }
  } catch (_) { result = ''; }

  tempSvg.remove();
  return result;
}

// ═══════════════════════════════════════════════════════════
// COMPOUND PATH MERGER (the core processor)
// ═══════════════════════════════════════════════════════════

// ALL output paths are purely filled — no stroke attributes.
// Strokes are "baked" into fill geometry:
//   - Closed stroke-only shapes → evenodd fill (outer + inset inner boundary)
//   - Filled paths (scaled) → compensating stroke outline merged into fill
//   - Open stroked / filled+stroked → stroke outline converted to fill
function flattenToCompoundPaths(contentG, s) {
  const SHAPE_TAGS = new Set(['path', 'line', 'circle', 'ellipse', 'rect', 'polyline', 'polygon']);
  const SW = 1;

  const cgStroke      = contentG.getAttribute('stroke')            || 'none';
  const cgFill        = contentG.getAttribute('fill')              || 'none';
  const cgStrokeWidth = contentG.getAttribute('stroke-width')      || '1';
  const cgLinecap     = contentG.getAttribute('stroke-linecap')    || '';
  const cgLinejoin    = contentG.getAttribute('stroke-linejoin')   || '';
  const cgMiterlimit  = contentG.getAttribute('stroke-miterlimit') || '';

  function styleVal(node, prop) {
    const sv = node.getAttribute('style') || '';
    const m = sv.match(new RegExp('(?:^|;)\\s*' + prop + '\\s*:\\s*([^;]+)'));
    return m ? m[1].trim() : '';
  }

  function makeInnerD(node, tag) {
    const f = v => parseFloat(v || '0');
    const tmp = node.ownerDocument.createElementNS('http://www.w3.org/2000/svg', tag);
    if (tag === 'rect') {
      const x = f(node.getAttribute('x')), y = f(node.getAttribute('y'));
      const w = f(node.getAttribute('width')), h = f(node.getAttribute('height'));
      const rxRaw = f(node.getAttribute('rx')), ryRaw = f(node.getAttribute('ry') || node.getAttribute('rx'));
      const iw = w - 2 * SW, ih = h - 2 * SW;
      if (iw <= 0 || ih <= 0) return '';
      tmp.setAttribute('x',      x + SW);
      tmp.setAttribute('y',      y + SW);
      tmp.setAttribute('width',  iw);
      tmp.setAttribute('height', ih);
      tmp.setAttribute('rx', Math.max(rxRaw - SW, 0));
      tmp.setAttribute('ry', Math.max(ryRaw - SW, 0));
    } else if (tag === 'circle') {
      const r = f(node.getAttribute('r'));
      if (r - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('r',  r - SW);
    } else if (tag === 'ellipse') {
      const rx = f(node.getAttribute('rx')), ry = f(node.getAttribute('ry'));
      if (rx - SW <= 0 || ry - SW <= 0) return '';
      tmp.setAttribute('cx', node.getAttribute('cx') || '0');
      tmp.setAttribute('cy', node.getAttribute('cy') || '0');
      tmp.setAttribute('rx', rx - SW);
      tmp.setAttribute('ry', ry - SW);
    }
    return shapeToPathD(tmp);
  }

  const items = [];
  function collect(node) {
    if (node.nodeType !== 1) return;
    const tag = node.tagName.toLowerCase();
    if (SHAPE_TAGS.has(tag)) {
      const stroke      = node.getAttribute('stroke')            || styleVal(node, 'stroke')            || cgStroke;
      const fill        = node.getAttribute('fill')              || styleVal(node, 'fill')              || cgFill;
      const strokeWidth = node.getAttribute('stroke-width')      || styleVal(node, 'stroke-width')      || cgStrokeWidth;
      const linecap     = node.getAttribute('stroke-linecap')    || styleVal(node, 'stroke-linecap')    || cgLinecap;
      const linejoin    = node.getAttribute('stroke-linejoin')   || styleVal(node, 'stroke-linejoin')   || cgLinejoin;
      const miterlimit  = node.getAttribute('stroke-miterlimit') || styleVal(node, 'stroke-miterlimit') || cgMiterlimit;

      const hasStroke = stroke && stroke !== 'none';
      const hasFill   = fill   && fill   !== 'none';

      // ── Branch 1: Inside-stroke-to-fill for closed shapes (exact analytical geometry) ──
      const isClosedSimple = tag === 'rect' || tag === 'circle' || tag === 'ellipse';
      const isClosedPathEl = tag === 'path' && isClosedPath(shapeToPathD(node));
      if (hasStroke && !hasFill && (isClosedSimple || isClosedPathEl)) {
        const outerD = shapeToPathD(node);
        if (!outerD) return;
        const innerD = isClosedSimple ? makeInnerD(node, tag) : makeInnerDFromPath(outerD);
        const combinedD = innerD ? outerD + ' ' + innerD : outerD;
        items.push({
          d:           combinedD,
          fill:        stroke,
          stroke:      'none',
          fillRule:    innerD ? 'evenodd' : 'nonzero',
          strokeWidth: '0',
          linecap: '', linejoin: '', miterlimit: '',
        });
        return;
      }

      // ── Branch 2: Filled paths with compensating stroke ──
      // Plugin outputs strokes natively; code.js will outline them via Figma API.
      if (hasFill && !hasStroke) {
        const d = shapeToPathD(node);
        if (!d) return;
        const compSW = Math.max(0, 1 - s);
        if (compSW > 0.001) {
          items.push({
            d, fill,
            stroke: fill, strokeWidth: String(compSW),
            fillRule: node.getAttribute('fill-rule') || 'nonzero',
            linecap: '', linejoin: '', miterlimit: '',
          });
        } else {
          items.push({
            d, fill,
            stroke: 'none', strokeWidth: '0',
            fillRule: node.getAttribute('fill-rule') || 'nonzero',
            linecap: '', linejoin: '', miterlimit: '',
          });
        }
        return;
      }

      // ── Branch 3: Stroked paths — keep strokes for Figma import ──
      // code.js will outline strokes after createNodeFromSvg.
      const d = shapeToPathD(node);
      if (!d) return;

      if (hasStroke && !hasFill) {
        items.push({
          d,
          fill: 'none',
          stroke, strokeWidth: String(SW),
          fillRule: node.getAttribute('fill-rule') || 'nonzero',
          linecap, linejoin, miterlimit,
        });
      } else if (hasStroke && hasFill) {
        items.push({
          d, fill,
          stroke, strokeWidth: String(SW),
          fillRule: node.getAttribute('fill-rule') || 'nonzero',
          linecap, linejoin, miterlimit,
        });
      } else {
        items.push({
          d, fill: hasFill ? fill : 'none',
          stroke: 'none', strokeWidth: '0',
          fillRule: node.getAttribute('fill-rule') || 'nonzero',
          linecap: '', linejoin: '', miterlimit: '',
        });
      }
    } else {
      Array.from(node.childNodes).forEach(collect);
    }
  }
  Array.from(contentG.childNodes).forEach(collect);
  if (!items.length) return;

  // Group by style signature; keep evenodd paths separate
  const groups = new Map();
  let eoCounter = 0;
  items.forEach(it => {
    const base = [it.stroke, it.fill, it.strokeWidth, it.linecap, it.linejoin, it.miterlimit, it.fillRule].join('|');
    const key = it.fillRule === 'evenodd' ? base + '|eo' + (eoCounter++) : base;
    if (!groups.has(key)) groups.set(key, { it, dParts: [] });
    groups.get(key).dParts.push(it.d);
  });

  while (contentG.firstChild) contentG.removeChild(contentG.firstChild);
  ['stroke', 'fill', 'stroke-width', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit'].forEach(a =>
    contentG.removeAttribute(a));

  const ns = 'http://www.w3.org/2000/svg';
  groups.forEach(({ it, dParts }) => {
    const p = contentG.ownerDocument.createElementNS(ns, 'path');
    p.setAttribute('d', dParts.join(' '));
    if (it.fillRule === 'evenodd') p.setAttribute('fill-rule', 'evenodd');
    p.setAttribute('fill', it.fill || 'none');
    // Emit stroke attributes — code.js will outline strokes via Figma API
    if (it.stroke && it.stroke !== 'none') {
      p.setAttribute('stroke', it.stroke);
      p.setAttribute('stroke-width', it.strokeWidth || '1');
      if (it.linecap)    p.setAttribute('stroke-linecap', it.linecap);
      if (it.linejoin)   p.setAttribute('stroke-linejoin', it.linejoin);
      if (it.miterlimit) p.setAttribute('stroke-miterlimit', it.miterlimit);
    }
    contentG.appendChild(p);
  });
}

// ═══════════════════════════════════════════════════════════
// MAIN NORMALIZER
// ═══════════════════════════════════════════════════════════

function normalizeSVG(svgString, keyline, size) {
  const { doc, root: svgEl } = parseSVGString(svgString);
  const serializer = new XMLSerializer();

  ensureViewBox(svgEl);

  const bboxData = getContentBBox(svgString);
  if (!bboxData) throw new Error('Could not compute bounding box');

  const { x: bx, y: by, width: bw, height: bh, vbInfo } = bboxData;

  const kl = SPEC.keylines[size][keyline];
  const sx = kl.w / bw;
  const sy = kl.h / bh;
  const s = Math.min(sx, sy);

  const tx = size / 2 - (bx + bw / 2) * s;
  const ty = size / 2 - (by + bh / 2) * s;

  const { doc: outDoc, root: outSvg } = parseSVGString(svgString);

  outSvg.setAttribute('viewBox', `0 0 ${size} ${size}`);
  outSvg.setAttribute('width', String(size));
  outSvg.setAttribute('height', String(size));
  outSvg.setAttribute('fill', 'none');
  outSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  outSvg.removeAttribute('class');
  outSvg.removeAttribute('style');
  outSvg.removeAttribute('preserveAspectRatio');

  const childrenToWrap = Array.from(outSvg.childNodes).filter(n => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toLowerCase();
    return tag !== 'defs' && tag !== 'title' && tag !== 'desc' && tag !== 'metadata';
  });

  const contentG = outDoc.createElementNS('http://www.w3.org/2000/svg', 'g');
  contentG.setAttribute('id', 'icon-content');

  childrenToWrap.forEach(child => contentG.appendChild(child));

  contentG.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  const STROKE_INHERIT_ATTRS = [
    'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
    'stroke-miterlimit', 'stroke-opacity', 'stroke-dasharray', 'stroke-dashoffset',
  ];
  STROKE_INHERIT_ATTRS.forEach(attr => {
    const val = outSvg.getAttribute(attr);
    if (val && !contentG.hasAttribute(attr)) contentG.setAttribute(attr, val);
    outSvg.removeAttribute(attr);
  });

  walkFlatten(contentG, [s, 0, 0, s, tx, ty]);

  flattenToCompoundPaths(contentG, s);

  outSvg.appendChild(contentG);

  outSvg.querySelectorAll('style').forEach(s => s.parentNode.removeChild(s));

  outSvg.querySelectorAll('[clip-path]').forEach(el => el.removeAttribute('clip-path'));
  outSvg.querySelectorAll('clipPath').forEach(el => el.parentNode.removeChild(el));

  return serializer.serializeToString(outSvg);
}

// ═══════════════════════════════════════════════════════════
// MESSAGE HANDLER
// ═══════════════════════════════════════════════════════════

function updateProgress(current, total, name) {
  document.getElementById('status').textContent = `Processing: ${name}`;
  document.getElementById('count').textContent = `${current + 1} / ${total}`;
  document.getElementById('progress-fill').style.width = ((current + 1) / total * 100) + '%';
}

window.onmessage = async (event) => {
  const msg = event.data.pluginMessage;
  if (!msg) return;

  if (msg.type === 'normalize-icons') {
    const icons = msg.icons;

    document.getElementById('waiting').style.display = 'none';
    document.getElementById('progress-section').classList.add('visible');

    const results = [];

    for (let i = 0; i < icons.length; i++) {
      const icon = icons[i];
      updateProgress(i, icons.length, icon.name);

      // Yield to UI so progress bar renders
      await new Promise(r => setTimeout(r, 10));

      try {
        const bbox = getContentBBox(icon.svg);
        const keyline = detectKeyline(icon.svg, bbox);

        const svgs = {};
        for (const size of [16, 24, 32]) {
          svgs[size] = normalizeSVG(icon.svg, keyline, size);
        }

        results.push({
          name: icon.name,
          keyline: keyline,
          svgs: svgs,
          error: null,
        });
      } catch (e) {
        results.push({
          name: icon.name,
          keyline: null,
          svgs: null,
          error: e.message || 'Unknown error',
        });
      }
    }

    // Show done state
    document.getElementById('progress-section').classList.remove('visible');
    document.getElementById('done-section').classList.add('visible');

    const success = results.filter(r => !r.error).length;
    const failed = results.filter(r => r.error).length;
    document.getElementById('done-msg').textContent = `Normalized ${success} icon(s)`;
    if (failed > 0) {
      document.getElementById('error-msg').textContent = `${failed} icon(s) failed`;
    }

    // Send results back to code.js
    parent.postMessage({ pluginMessage: {
      type: 'normalize-results',
      results: results,
    }}, '*');
  }
};
</script>
</body>
</html>
